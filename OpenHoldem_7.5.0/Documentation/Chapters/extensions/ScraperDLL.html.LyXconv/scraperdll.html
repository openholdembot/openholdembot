<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="generator" content="http://www.nongnu.org/elyxer/"/>
<meta name="create-date" content="2014-12-26"/>
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all"/>
<title>Converted document</title>
</head>
<body>
<div id="globalWrapper">
<h1 class="Section">
<a class="toc" name="toc-Section-1"></a><a class="IndexReference" name="entry-Scraper-DLL-0" href="#index-Scraper-DLL">↓</a>Scraper Override <a class="IndexReference" name="entry-DLL-0" href="#index-DLL">↓</a>DLL<a class="Label" name="sec:Scraper-Override-DLL"> </a>
</h1>
<div class="Unindented">
The scraper override DLL extension provides for a user-specified override of the output of the screen scraper engine. Sometimes, better game state information can be retrieved from poker client controls that are not scrapable by the pixel-driven scraper engine in OpenHoldem, such as by parsing the chat box. Parsing the chat box would require direct memory reading of the poker client, or DLL injection. The approach for such a chat box parsing is beyond the scope of this document, but a good discussion on the topic can be found on CodingTheWheel (<a class="FlexURL" href="http://www.codingthewheel.com/archives/how-i-built-a-working-online-poker-bot-7">http://www.codingthewheel.com/archives/how-i-built-a-working-online-poker-bot-7</a>): 
</div>
<div class="Indented">
Immediately after the screen scrape is complete, OpenHoldem will pass a pointer to a structure containing the results of the scrape to your override DLL. This is not a const pointer reference, so any of the members of the struct can be changed directly. The prototype for the method called by OpenHoldem is quite straightforward:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">SCRAPERDLL_API void OverrideScraper(SScraperState *state);
</pre>
</div>

</div>
<div class="Indented">
No casting required. The members of the SScraperState struct are as follows:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">struct SScraperState { 
    char title[512];
    unsigned int card_common[5]; 
    unsigned int card_player[10][2]; 
    unsigned int card_player_for_display[2]; 
    bool dealer[10]; 
    bool sitting_out[10]; 
    CString seated[10]; 
    CString active[10]; 
    CString name[10]; 
    double balance[10]; 
    bool name_good_scrape[10]; 
    bool balance_good_scrape[10]; 
    double bet[10]; double pot[10]; 
    CString button_state[10]; 
    CString i86X_button_state[10]; 
    CString i86_button_state; 
    CString button_label[10]; 
    double sblind; 
    double bblind; 
    double bbet; 
    double ante; 
    LimitType limit; 
    double handnumber; 
    bool istournament; 
};
</pre>
</div>

</div>
<div class="Indented">
Any of these can be changed like so (which will give you four-of-a-kind Aces)
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">SCRAPERDLL_API void OverrideScraper(SScraperState *state) { 
    state-&gt;card_common[0] = StdDeck_MAKE_CARD(
        StdDeck_Rank_ACE, StdDeck_Suit_HEARTS); 
    state-&gt;card_common[1] = StdDeck_MAKE_CARD(
        StdDeck_Rank_ACE, StdDeck_Suit_DIAMONDS); 
    state-&gt;card_common[2] = StdDeck_MAKE_CARD(
        StdDeck_Rank_ACE, StdDeck_Suit_SPADES); 
    state-&gt;card_common[3] = StdDeck_MAKE_CARD(
        StdDeck_Rank_ACE, StdDeck_Suit_CLUBS); 
}
</pre>
</div>

</div>
<div class="Indented">
And on return, OpenHoldem will instantly use the changed values instead of the scraped values.
</div>

<hr class="footer"/>
<div class="footer" id="generated-by">
Document generated by <a href="http://elyxer.nongnu.org/">eLyXer 1.2.5 (2013-03-10)</a> on <span class="create-date">2014-12-26T16:55:24.421000</span>
</div>
</div>
</body>
</html>
