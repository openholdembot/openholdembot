<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="regionrecords.tex"> 
<meta name="date" content="2010-05-07 02:56:00"> 
<link rel="stylesheet" type="text/css" href="regionrecords.css"> 
</head><body bgcolor="#CCCCFF" 
>
   <h3 class="sectionHead"><a 
 id="x1-1000"></a>Region Records</h3>
   <h4 class="subsectionHead"><a 
 id="x1-2000"></a>Description </h4>
<!--l. 38--><p class="noindent" >The purpose of the Region records is to describe named rectangular areas on a poker
table, each of which contains an element of the game state. These regions will &#8220;return&#8221;
values to the OpenHoldem game state engine, depending on the type of transform
selected.
<!--l. 44--><p class="indent" >   An example will make this clearer. Each seat at the table will have two cards in
front it, and we want our screen scraper to tell the OpenHoldem game state
engine what those cards are. If the casino client displays a group of pixels for
our first hole card, that to a human being looks like an ace of hearts, we need
somehow to tell the screen scraper to &#8220;return&#8221; &#8220;Ah&#8221; to the game state engine each
time that group of pixels is seen in one of the card locations. To do this we
collect an image for that ace of hearts, then setup a region record that returns
&#8220;Ah&#8221; to OpenHoldem when that ace of hearts is seen during real live game
play.
   <h4 class="subsectionHead"><a 
 id="x1-3000"></a>Manipulating region records using OpenScrape</h4>
<!--l. 59--><p class="noindent" >To create a new region record, select the &#8220;Regions&#8221; category in the record tree display on
the Table Map Editor window, and click the &#8220;New&#8221; button. A window will be displayed
that allows you to select the name of the region to create. After creating the record, you
can use the controls on the right side of the Table Map Editor window, as described
below, to change the settings for the new record. To edit an existing region record, select
the record in the record tree display on the Table Map Editor window. Immediately after
selecting the record, the controls on the right side of the Table Map Editor window are
updated with the settings for the selected region record. These can then be
changed, as described below. To delete an existing region record, select the
record in the record tree display on the Table Map Editor window, and click
the &#8220;Delete&#8221; button. A window will be displayed asking for verification of this
action.
<!--l. 75--><p class="indent" >   Note: The Insert and Delete keys can also be used as a shortcut for adding and
deleting Region records.
<!--l. 78--><p class="indent" >   Note: Regions can also be selected by left clicking within the region&#8217;s flashing red
rectangle that is layered on top of the poker table image on the Main window. If multiple
regions are layered on top of each other, clicking again on the same area will select the
next region below the selected region. This only works for two regions. If three or
more regions are layered on top of each other, the selection tree will need to be
used.
<!--l. 86--><p class="indent" >   The majority of the right side of the Table Map Editor window is used to manipulate
the parameters of the region record.
<!--l. 89--><p class="indent" >   Figure 4.5-11 OpenScrape Rectangle Group Box !!!
<!--l. 91--><p class="indent" >   Starting at the top, there is a rectangle group box. This group box allows you to
define the extents (left, right, top, bottom) of the region record&#8217;s bounding rectangle.
The bounds are inclusive &#8211; in other words, a rectangle defined as left=0, right=5, top=0
and bottom=6 will be 6 pixels wide and 7 pixels high. The rectangle settings can be
direct entered into the controls, you can use the spinners next to the controls, or you

can use the rectangle drawing tool to quickly draw the rectangle on the poker
table.
<!--l. 100--><p class="indent" >   To use the rectangle drawing tool, click once on this control:
<!--l. 102--><p class="indent" >   <img 
src="regionrecords0x.png" alt="PIC" class="graphics"   ><!--tex4ht:graphics  
name="regionrecords0x.png" src="0E__Dokumente_und_Einstellungen_Development_Des___pters_tablemaps_images_OS_RectangleDrawTool.eps"  
-->
<!--l. 104--><p class="indent" >   ...then move your mouse cursor to the Main OpenScrape window where the image of
the poker table is displayed. The mouse cursor will change to look like crosshairs with an
arrow pointing right and down. Left click and hold the mouse button anywhere on the
poker table image to define the left-top corner of the rectangle. Drag to the right and
down, and when you reach the right-bottom corner of the rectangle, release the left
mouse button.
<!--l. 112--><p class="indent" >   A zoomed view of the region is displayed in the box at the bottom right of the Table
Map Editor window. The Table Map Editor window can be enlarged, if needed, to show
the entire region. Use the Zoom Level control to adjust the zoom level in this
display.
<!--l. 117--><p class="indent" >   <img 
src="regionrecords1x.png" alt="PIC" class="graphics"   ><!--tex4ht:graphics  
name="regionrecords1x.png" src="1E__Dokumente_und_Einstellungen_Development_Des____Chapters_tablemaps_images_OS_NudgeGroupBox.eps"  
-->
<!--l. 119--><p class="indent" >   To the right of the rectangle group box is the nudge group box. These controls allow
you to adjust the size and position of the region record&#8217;s rectangle in a variety of ways.
The group of six controls on the left, starting from top left and moving clockwise, allow
you to make the rectangle taller, shorter, thinner, smaller, bigger and wider. The group
of 8 controls on the right, starting from top left and moving clockwise, allow you to
move the rectangle up-left, up, up-right, right, down-right, down, down-left, and
left.
<!--l. 128--><p class="indent" >   Note: Regions can also be moved by first selecting the region by left clicking within
the region&#8217;s flashing red rectangle on the poker table image on the Main window,
then by holding the Shift key and dragging and dropping the region to its new
location.
   <h4 class="subsectionHead"><a 
 id="x1-4000"></a>Keyboard shortcuts to move and resize regions</h4>
           <ul class="itemize1">
        <li class="itemize">Arrow keys - Move the region 1 pixel
           </li>
        <li class="itemize">Numpad keys 1, 3, 7, and 9 &#8211; Move the region diagonally 1 pixel
           </li>
        <li class="itemize">Shift + Arrow keys - Move the region 5 pixels
           </li>
        <li class="itemize">Control + Arrow keys - Resize the region by 1 pixel
           </li>
        <li class="itemize">Control + Shift + Arrow keys &#8211; Resize the region by 5 pixels</li></ul>
<!--l. 144--><p class="noindent" ><img 
src="regionrecords2x.png" alt="PIC" class="graphics"   ><!--tex4ht:graphics  
name="regionrecords2x.png" src="2E__Dokumente_und_Einstellungen_Development_Des____tablemaps_images_OS_RegionRecordParameters.eps"  
-->
<!--l. 146--><p class="indent" >   The next set of controls allows you to set the remainder of the parameters on a

region record. Here you can set the type of transform, the radius of the RGB color cube,
and the center color of the RGB color cube. The use of RGB color cubes for
transforms of type Color and Text is described in the technical reference below.
Also in this group of controls is an eyedropper button that is used to populate
the color parameters, as opposed to directly entering those values. To use the
eyedropper, click once on the eyedropper button, then hover over the region&#8217;s image
display at the bottom of the Table Map Editor window. When the color you
want is present in the four color fields, click the left mouse button to lock them
in.
<!--l. 158--><p class="indent" >   As a helpful reference, the &#8220;Avg Color&#8221; fields are populated with the calculated
average color of all pixels in the region. This is useful for finding RGB color cube centers
and for text transform separations.
<!--l. 163--><p class="indent" >   <img 
src="regionrecords3x.png" alt="PIC" class="graphics"   ><!--tex4ht:graphics  
name="regionrecords3x.png" src="3E__Dokumente_und_Einstellungen_Development_Des____tablemaps_images_OS_TransformResultPreview.eps"  
-->
<!--l. 165--><p class="indent" >   This field provides an instant preview of the results of combining the current pixels
in the region with the current transform for that region. If this is a Text transform, the
actual transformed ASCII text is displayed. If this is a Color transform, True or False is
displayed, depending if the region&#8217;s average color is inside or outside of the defined RGB
color cube. If this is a Hash transform, the value of the matching Hash record is
displayed. If this is an Image transform, the value of the matching Image record is
displayed.
<!--l. 175--><p class="indent" >   <img 
src="regionrecords4x.png" alt="PIC" class="graphics"   ><!--tex4ht:graphics  
name="regionrecords4x.png" src="4E__Dokumente_und_Einstellungen_Development_Des____tablemaps_images_OS_PixelSeparationDisplay.eps"  
-->
<!--l. 177--><p class="indent" >   If your region is defined to have a Text transform, then the Pixel Separation window
will be populated with a preview of this separation. The key to good Text transformation
is the separation of foreground pixel colors from background pixel colors. In this display,
foreground pixels will be shown as an &#8220;X&#8221;, and background pixels as a blank space. The
size of the font used in this display can be adjusted with the &#8220;+&#8221; and &#8220;-&#8220; buttons to the
right.
<!--l. 186--><p class="indent" >   Note: Remember that the whole purpose of a region definition, with a given type of
transformation, is to tell the screen scraper what the pixels mean that are displayed on
the screen within that region. The return value of the transformation is provided to the
OpenHoldem game state engine which then uses those values to establish the
game state and to provide various information that your bot logic needs to
make action decisions. A human can easily look at the balance for seat #2 and
see that it is $950.12. For a computer it is harder &#8211; we need to specify the
rectangle that bounds this balance region, define it as a text transform, choose a
color that lets the screen scraper identify foreground from background pixels,
and then collect each of the individual font characters (more on this below) so
that the screen scraper engine can look up the actual ASCII text for these
pixels.
<!--l. 201--><p class="indent" >   The Edit menu of on the Main window contains a &#8220;Duplicate Region&#8221; entry, which is
intended to allow the quick creation of related region records. First, select a
region record from the tree display on the Table Map Editor window, then select
Edit/Duplicate Region from the Main window. This action will display this

window:
<!--l. 208--><p class="indent" >   Figure 4.5-17 OpenScrape Duplicate Region window
<!--l. 210--><p class="indent" >   In this case, the p0balance region was selected. You are given the option to
duplicate the selected region record to other region records of the same type.
In this case, all of the unpopulated pXbalance and uXbalance region records
are candidates. You can select one or more than one destination record here
(using the standard Windows Ctrl and Shift multi-select capability) to copy the
selected region to. When you click the OK button, the new region records will be
created for you, and you can then move them where needed and adjust them
appropriately.
   <h4 class="subsectionHead"><a 
 id="x1-5000"></a>Technical Reference</h4>
<!--l. 222--><p class="noindent" >In the Table Map (.tm) file, these records will be preceded with the characters "r$".
Region records have the following format:
<!--l. 226--><p class="indent" >   r$&#x003C;name&#x003E; &#x003C;left&#x003E; &#x003C;top&#x003E; &#x003C;right&#x003E; &#x003C;bottom&#x003E; &#x003C;color&#x003E; &#x003C;radius&#x003E; &#x003C;transform&#x003E;
<!--l. 228--><p class="indent" >   &#x003C;name&#x003E; is the name of the record (see table below) &#x003C;left&#x003E;, &#x003C;top&#x003E;, &#x003C;right&#x003E; and
&#x003C;bottom&#x003E; are integer values within the casino table, where the upper left corner of the
client area is considered to be 0, 0 &#x003C;color&#x003E; is a 1-8 character hexadecimal number in the
form AABBGGRR (Microsoft Window&#8217;s COLORREF format (<a 
href="!!!" class="url" ><span 
class="ectt-1000">!!!</span></a>)). The usage of the
color value is dependent on the transform selected. &#x003C;radius&#x003E; is an RGB color distance.
&#x003C;transform&#x003E; describes the engine algorithm that should be used to interpret the pixels
in the region.
   <h4 class="subsectionHead"><a 
 id="x1-6000"></a>Valid Transforms And Their Desciption</h4>

   <div class="tabular"> <table id="TBL-1" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-1-1g"><col 
id="TBL-1-1"></colgroup><colgroup id="TBL-1-2g"><col 
id="TBL-1-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-1-"><td  style="white-space:wrap; text-align:left;" id="TBL-1-1-1"  
class="td11"> <!--l. 242--><p class="noindent" >Transform    </td><td  style="white-space:wrap; text-align:left;" id="TBL-1-1-2"  
class="td11"> <!--l. 242--><p class="noindent" >Description                                                                              </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-2-"><td  style="white-space:wrap; text-align:left;" id="TBL-1-2-1"  
class="td11"> <!--l. 245--><p class="noindent" >N (none)       </td><td  style="white-space:wrap; text-align:left;" id="TBL-1-2-2"  
class="td11"> <!--l. 245--><p class="noindent" >This
  is
  used
  for
  those
  regions
  that
  do
  not
  need
  a
  transform
  as
  their
  only
  purpose
  is
  to
  describe
  a
  rectangle
  for
  use
  by
  the
  scraper
  engine.
  An
  example
  is
  button
  location
  (i0button
  -
  i9button)
  which
  informs
  the
  Autoplayer
  engine
  of
  the
  allowed
  rectangle
  for
  mouse
  clicks.                                                                                     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-3-"><td  style="white-space:wrap; text-align:left;" id="TBL-1-3-1"  
class="td11"> <!--l. 250--><p class="noindent" >C (color)       </td><td  style="white-space:wrap; text-align:left;" id="TBL-1-3-2"  
class="td11"> <!--l. 250--><p class="noindent" >This
  is
  a
  calculation
  of
  the
  average
  RGB
  color
  for
  the
  entire
  region.
  Used
  in
  conjunction
  with
  the
  radius,
  the
  engine
  will
  determine
  if
  the
  contents
  of
  the
  region,
  as
  seen
  during
  game
  play,
  match
  the
  color/radius
  as
  specified
  in
  the
  Table
  Map.
  The
  color
  value
  in
  the
  region
  record
  defines
  the
  center
  of
  a
  cube,
  and
  the
  radius
  defines
  the
  dimensions
  of
  that
  cube.
  This
  cube
  is
  then
  mapped
  to
  an
  RGB
  color
  space,
  and
  if
  the
  average
  color
  of
  the
  region
  falls
  within
  this
  cube,
  then
  a
  match
  is
  reported.
  A
  negative
  radius
  can
  also
  be
  specified,
  in
  which
  case
  if
  the
  average
  color
  of
  the
  region
  falls
  outside
  of
  the
  cube,
  then
  a
  match
  is
  reported.                                                                                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-4-"><td  style="white-space:wrap; text-align:left;" id="TBL-1-4-1"  
class="td11"> <!--l. 261--><p class="noindent" >I (image)       </td><td  style="white-space:wrap; text-align:left;" id="TBL-1-4-2"  
class="td11"> <!--l. 261--><p class="noindent" >This
  transform
  does
  two
  things.
  It
  first
  searches
  the
  Image
  records
  in
  the
  Table
  Map
  for
  a
  pixel-by-pixel
  match,
  and
  returns
  the
  value
  of
  that
  Image
  record
  if
  a
  match
  is
  found.
  If
  no
  pixel-by-pixel
  match
  is
  found,
  the
  transform
  then
  searches
  for
  the
  closest
  match,
  based
  on
  an
  perceptual
  difference
  algorithm
  (<a 
href="http://pdiff.sourceforge.net/" class="url" ><span 
class="ectt-1000">http://pdiff.sourceforge.net/</span></a>).
  There
  is
  an
  internal
  hard-coded
  limit,
  which
  prevents
  Image
  records
  from
  matching
  the
  region
  if
  65%
  or
  more
  of
  available
  pixels
  of
  that
  region
  do
  not
  match.
  If
  this
  limit
  did
  not
  exist,
  then
  clearly
  non-matching
  regions
  could
  return
  all
  sorts
  of
  junk.
  This
  exact-match-to-pdiff
  failover
  is
  automatic,
  and
  requires
  no
  additional
  work
  from
  the
  Table
  Map
  creator
  other
  than
  to
  set
  the
  transform
  to
  "I"
  and
  to
  collect
  the
  images.
  This
  is
  a
  powerful
  transform,
  but
  be
  aware
  that
  this
  power
  comes
  at
  the
  cost
  of
  CPU
  cycles.                                                                                     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-5-"><td  style="white-space:wrap; text-align:left;" id="TBL-1-5-1"  
class="td11"> <!--l. 275--><p class="noindent" >T (text)        </td><td  style="white-space:wrap; text-align:left;" id="TBL-1-5-2"  
class="td11"> <!--l. 275--><p class="noindent" >This
  is
  an
  OCR-algorithm
  (<a 
href="http://en.wikipedia.org/wiki/Optical_character_recognition" class="url" ><span 
class="ectt-1000">http://en.wikipedia.org/wiki/Optical_character_recognition</span></a>)
  for
  the
  purpose
  of
  converting
  screen
  pixels
  to
  ASCII
  text.
  The
  color
  cube
  specifications
  (as
  in
  the
  C
  transform)
  are
  used
  to
  separate
  the
  foreground
  from
  the
  background
  pixels.
  A
  lookup
  is
  then
  performed
  against
  the
  Font
  records
  in
  the
  Table
  Map
  on
  a
  character
  by
  character
  basis
  to
  produce
  a
  resultant
  text
  string.                                                                                     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-6-"><td  style="white-space:wrap; text-align:left;" id="TBL-1-6-1"  
class="td11"> <!--l. 282--><p class="noindent" >Hn (hash n)   </td><td  style="white-space:wrap; text-align:left;" id="TBL-1-6-2"  
class="td11"> <!--l. 282--><p class="noindent" >This
  transform
  reduces
  the
  contents
  of
  the
  rectangle
  to
  a
  32-bit
  value.
  OpenHoldem
  and
  OpenScrape
  use
  only
  a
  single,
  well
  respected
  hash
  algorithm
  that
  is
  open
  for
  public
  review.
  Because
  of
  the
  selection
  of
  this
  algorithm,
  we
  have
  not
  yet
  seen
  a
  hash
  collision
  (that
  did
  not
  have
  an
  unrelated
  root
  cause,
  like
  record
  duplication).
  That
  is
  not
  to
  say
  that
  a
  hash
  collision
  is
  not
  impossible,
  however
  the
  mapping
  of
  52
  card
  images
  (for
  example)
  into
  a
  32-bit
  address
  space
  makes
  this
  highly
  unlikely.
  If
  a
  collision
  ever
  occurs,
  there
  is
  the
  option
  to
  use
  hash
  types
  other
  than
  Type
  0.
  Types
  0-3
  all
  use
  different
  hash
  seeds
  with
  the
  same
  algorithm,
  and
  thus
  if
  a
  collision
  is
  seen,
  one
  could
  simply
  change
  the
  hash
  type
  for
  that
  region.
  <!--l. 294--><p class="noindent" >The
  Type
  0
  hash
  algorithm
  uses
  all
  pixels
  in
  a
  region
  to
  calculate
  a
  hash.
  To
  use
  specific
  pixels
  in
  the
  region,
  use
  Types
  1-3.
  Types
  1-3
  default
  to
  using
  all
  pixels
  in
  a
  region
  as
  well,
  but
  if
  Hash
  Point
  records
  are
  present
  in
  the
  Table
  Map
  and
  of
  a
  matching
  type,
  the
  engine
  will
  use
  those
  specific
  points
  for
  calculation
  of
  the
  hash.
  <!--l. 300--><p class="noindent" >Once
  a
  region
  is
  hashed,
  the
  resultant
  32-bit
  hash
  value
  is
  then
  looked
  up
  in
  the
  h$
  records
  in
  the
  Table
  Map.
  If
  a
  match
  is
  found,
  the
  name
  of
  the
  h$
  record
  is
  returned
  and
  acted
  on
  appropriately
  (i.e.
  common
  card
  1
  is
  Queen-Hearts,
  Fold
  button
  is
  present,
  Player
  2
  is
  seated,
  etc.)                                                                                       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-1-7-"><td  style="white-space:wrap; text-align:left;" id="TBL-1-7-1"  
class="td11">             </td> </tr></table>

</div>
   <h4 class="subsectionHead"><a 
 id="x1-7000"></a>Valid region records and their descriptions </h4>
<a 
 id="x1-7001r1"></a>   <!--l. 313--><div class="longtable"> <table id="TBL-2" class="longtable" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1"></colgroup><colgroup id="TBL-2-2g"><col 
id="TBL-2-2"></colgroup>

<tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-1-1"  
class="td11">
 <!--l. 313--><p class="noindent" >Record        </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-1-2"  
class="td11">
 <!--l. 313--><p class="noindent" >Description                                                                              </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-2-1"  
class="td11">
 <!--l. 315--><p class="noindent" >           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-3-1"  
class="td11">            </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-3-2"  
class="td11"></td></tr>
<tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-4-1"  
class="td11">
 <!--l. 317--><p class="noindent" >c0cardface0
  -
  c0cardface4   </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-4-2"  
class="td11">
 <!--l. 317--><p class="noindent" >Common cards 0-4; represents the entire card, the best
  transformation is probably hash. Typically either c0cardfaceX is used,
  or c0cardfaceXrank / c0cardfaceXsuit, but not both. Valid results are
  a case-insensitive, two character string. The first character is the rank
  and should be one of: &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;, &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;, &#8220;8&#8221;, &#8220;9&#8221;, &#8220;t&#8221;, &#8220;j&#8221;, &#8220;q&#8221;,
  &#8220;k&#8221;, or &#8220;a&#8221;. The second character is the suit and should be one of: &#8220;c&#8221;,
  &#8220;d&#8221;, &#8220;h&#8221; or &#8220;s&#8221;. c0cardface0rank - c0cardface4rank Rank of common
  cards 0-4; the best transformation is probably text. Typically either
  c0cardfaceX is used, or c0cardfaceXrank / c0cardfaceXsuit, but not
  both. Valid results are case-insensitive, and are one of &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;,
  &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;, &#8220;8&#8221;, &#8220;9&#8221;, &#8220;10&#8221;, &#8220;t&#8221;, &#8220;j&#8221;, &#8220;q&#8221;, &#8220;k&#8221;, or &#8220;a&#8221;.                          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-5-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-5-1"  
class="td11">
 <!--l. 342--><p class="noindent" >c0cardface0suit
  -
  c0cardface4suit </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-5-2"  
class="td11">
 <!--l. 342--><p class="noindent" >Suit of common cards 0-4; the best transformation is probably text.
  Typically either c0cardfaceX is used, or c0cardfaceXrank /
  c0cardfaceXsuit, but not both. Valid results are case-insensitive, and
  are one of &#8220;c&#8221;, &#8220;d&#8221;, &#8220;h&#8221; or &#8220;s&#8221;.                                                      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-6-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-6-1"  
class="td11">
 <!--l. 348--><p class="noindent" >c0handnumber,
  c0handnumber1
  -
  c0handnumber9 </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-6-2"  
class="td11">
 <!--l. 348--><p class="noindent" >Ten regions to specify where the game state engine should find the
  current handnumber. The first region found with valid numeric
  information will be used and the remainder skipped. c0handnumber is
  searched first, then c0handnumber1 to c0handnumber9 in that order.  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-7-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-7-1"  
class="td11">
 <!--l. 353--><p class="noindent" >c0istournament </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-7-2"  
class="td11">
 <!--l. 353--><p class="noindent" >Used to identify if this table is a tournament game. Any transform
  can be used equally well with this region. If the result from this
  region&#8217;s transform is anything besides blank (empty string) then this
  region is considered to represent a tournament game.                        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-8-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-8-1"  
class="td11">
 <!--l. 358--><p class="noindent" >c0smallblind </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-8-2"  
class="td11">
 <!--l. 358--><p class="noindent" >Identifies the region on the poker table where the small blind can be
  found. Title text parsing is much easier to implement if that option is
  available, otherwise a text transformation can be used with this
  region to identify the small blind.                                                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-9-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-9-1"  
class="td11">
 <!--l. 363--><p class="noindent" >c0bigblind    </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-9-2"  
class="td11">
 <!--l. 363--><p class="noindent" >Identifies the region on the poker table where the big blind can be
  found. Title text parsing is much easier to implement if that option is
  available, otherwise a text transformation can be used with this
  region to identify the big blind. c0bigbet Identifies the region on the
  poker table where the big bet can be found. Title text parsing is
  much easier to implement if that option is available, otherwise a text
  transformation can be used with this region to identify the big bet.     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-10-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-10-1"  
class="td11">
 <!--l. 372--><p class="noindent" >c0ante         </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-10-2"  
class="td11">
 <!--l. 372--><p class="noindent" >Identifies the region on the poker table where the ante can be found.
  Title text parsing is much easier to implement if that option is
  available, otherwise a text transformation can be used with this
  region to identify the ante.                                                          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-11-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-11-1"  
class="td11">
 <!--l. 377--><p class="noindent" >c0pot0 -
  c0pot4         </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-11-2"  
class="td11">
 <!--l. 377--><p class="noindent" >The value of the main pot should be identified by c0pot0 using a text
  transform.                                                                                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-12-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-12-1"  
class="td11">
 <!--l. 380--><p class="noindent" >c0pot1 to
  c0pot4         </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-12-2"  
class="td11">
 <!--l. 380--><p class="noindent" >can be used to identify side pots if required. c0potNchipXY See chip
  scraping instructions for p0chipXY - p9chipXY below. The difference
  is that the "N" refers to the different pots - N=0 is the main pot,
  N=1-4 are side pots.                                                                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-13-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-13-1"  
class="td11">
 <!--l. 385--><p class="noindent" >c0limits,
  c0limits0 -
  c0limits9      </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-13-2"  
class="td11">
 <!--l. 385--><p class="noindent" >Identifies the region on the casino table where the limit information
  can be found; this region is used in conjunction with the Symbol
  records c0limits and c0limits0-c0limit9 text parse strings. This region
  should really only be used if title text parsing is not an option.          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-14-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-14-1"  
class="td11">
 <!--l. 390--><p class="noindent" >i0button -
  i9button       </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-14-2"  
class="td11">
 <!--l. 390--><p class="noindent" >Specifies the rectangular area in which the Autoplayer can click the
  mouse for each button 0-9.                                                          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-15-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-15-1"  
class="td11">
 <!--l. 393--><p class="noindent" >i0label -
  i9label         </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-15-2"  
class="td11">
 <!--l. 393--><p class="noindent" >Specifies the action that should be associated with buttons 0-9. By
  default, and if not overridden here, button 0 will be interpreted as the
  fold button, 1 as the call button, 2 as the raise button and 3 as the
  allin button.
  <!--l. 398--><p class="noindent" >The return value from the transformation of this region (hash or text)
  will determine how the scraper engine interprets the button. All
  values are changed to lowercase and have spaces and &#8217;-&#8217; removed.
  Only the leftmost characters will be tested "allin", "a11in", "allln",
  "a111n", "aiiin"&#x00A0;: button is seen as the allin button "raise", "ra1se",
  "ralse", "bet"&#x00A0;: button is seen as the raise button "call", "caii",
  "ca11"&#x00A0;: button is seen as the call button "check"&#x00A0;: button is seen as
  the check button "fold", "fo1d", "foid"&#x00A0;: button is seen as the fold
  button "autopost", "aut0p0st"&#x00A0;: button is seen as the autopost
  button "sitin", "s1t1n"&#x00A0;: button is seen as the sitin button "sitout",
  "s1tout", "sit0ut", "s1t0ut"&#x00A0;: button is seen as the sitout button
  "leave"&#x00A0;: button is seen as the leave button "prefold"&#x00A0;: button is seen
  as the prefold button
  <!--l. 421--><p class="noindent" >Examples: "All-In" will be recognized as allin; "Auto-post blinds"
  will be recognized as autopost                                                      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-16-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-16-1"  
class="td11">
 <!--l. 425--><p class="noindent" >i0labelY -
  i9labelY
  Where Y =
  0 - 9.           </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-16-2"  
class="td11">
 <!--l. 425--><p class="noindent" >As an adjunct to the iXlabel regions, the iXlabelY region definitions
  allow the specification of an alternative location with alternate
  properties, such as color, for any button. The specification of these
  regions is exactly as that of the iXlabel regions with an addition of a
  numeric (0 - 9) suffix. The iXlabel regions are searched first, then the
  iXlabelY regions. The first region that resolves to a text value will
  stop any subsequent evaluations.                                                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-17-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-17-1"  
class="td11">
 <!--l. 433--><p class="noindent" >i0state -
  i9state         </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-17-2"  
class="td11">
 <!--l. 433--><p class="noindent" >Specifies whether the button0 - button9 is live and available to be
  clicked. The best transformation is hash or color. If the leftmost
  characters of the result from this region&#8217;s transform are either &#8220;true&#8221;,
  "on", "yes", "checked" or "lit" then the button will be seen as
  available to be clicked. If any other result is returned, such as "false",
  then the button will be seen as not available to be clicked. Results are
  case-insensitive.                                                                         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-18-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-18-1"  
class="td11">
 <!--l. 443--><p class="noindent" >i3edit          </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-18-2"  
class="td11">
 <!--l. 443--><p class="noindent" >Specifies the rectangular region that can be used for entering a
  SWAG bet.                                                                              </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-19-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-19-1"  
class="td11">
 <!--l. 446--><p class="noindent" >i86button,
  i860button -
  i869button    </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-19-2"  
class="td11">
 <!--l. 446--><p class="noindent" >Similar to the i0button - i9button regions, however these regions are
  intended to be used to combat spam/popups that could occlude the
  poker window. If the corresponding state region returns true, the
  Autoplayer will try to click in this region to dismiss the spam/popup.  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-20-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-20-1"  
class="td11">
 <!--l. 451--><p class="noindent" >i86state,
  i860state -
  i869state      </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-20-2"  
class="td11">
 <!--l. 451--><p class="noindent" >The corresponding state regions for the i86button, i860button -
  i869button regions above. The best transformation is hash or color. If
  the leftmost characters of the result from this region&#8217;s transform are
  either &#8220;true&#8221;, "on", "yes", "checked" or "lit" then the button will be
  seen as available to be clicked. If any other result is returned, such as
  "false", then the button will be seen as not available to be clicked.
  Results are case-insensitive. p0active - p9active Used to determine if a
  player is active (sitting in) or not (sitting out). Any transform can be
  used equally well with this region. If the leftmost characters of the
  result from this region&#8217;s transform are either &#8220;true&#8221; or &#8220;active&#8221;, then
  the region is considered to be active. If any other result is returned,
  such as "false", "inactive", "out" or "away", then the chair is not
  considered to be active. Results are case-insensitive.                         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-21-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-21-1"  
class="td11">
 <!--l. 470--><p class="noindent" >p0balance -
  p9balance     </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-21-2"  
class="td11">
 <!--l. 470--><p class="noindent" >Used to identify a player&#8217;s balance. It only makes sense to use a text
  transform for these regions.                                                         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-22-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-22-1"  
class="td11">
 <!--l. 473--><p class="noindent" >p0bet -
  p9bet          </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-22-2"  
class="td11">
 <!--l. 473--><p class="noindent" >Used to identify a player&#8217;s bet. It only makes sense to use a text
  transform for these regions.                                                         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-23-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-23-1"  
class="td11">
 <!--l. 476--><p class="noindent" >p0cardback
  -
  p9cardback   </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-23-2"  
class="td11">
 <!--l. 476--><p class="noindent" >Used to identify when a seat 0-9 displays a card back. The best
  transformation is hash or color. If the leftmost characters of the result
  from this region&#8217;s transform are either &#8220;true&#8221; or &#8220;cardback&#8221;, then the
  region is considered to be showing a cardback. If any other result is
  returned, such as "false", then the chair is not considered to have be
  showing a cardback. Results are case-insensitive.                              </td>

</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-24-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-24-1"  
class="td11">
 <!--l. 483--><p class="noindent" >           </td>

   </tr>
<tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-25-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-25-1"  
class="td11">
 <!--l. 484--><p class="noindent" >p0cardface0
  -
  p9cardface0  </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-25-2"  
class="td11">
 <!--l. 484--><p class="noindent" >The first card for seats 0-9; represents the entire card. The best
  transformation is probably hash. Typically either pXcardfaceY is
  used, or pXcardfaceYrank / pXcardfaceYsuit, but not both. Valid
  results are a case-insensitive, two character string. The first character
  is the rank and should be one of: &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;, &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;, &#8220;8&#8221;, &#8220;9&#8221;,
  &#8220;t&#8221;, &#8220;j&#8221;, &#8220;q&#8221;, &#8220;k&#8221;, or &#8220;a&#8221;. The second character is the suit and should
  be one of: &#8220;c&#8221;, &#8220;d&#8221;, &#8220;h&#8221; or &#8220;s&#8221;.                                                      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-26-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-26-1"  
class="td11">
 <!--l. 499--><p class="noindent" >p0cardface1
  -
  p9cardface1  </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-26-2"  
class="td11">
 <!--l. 499--><p class="noindent" >The second card for seats 0-9; represents the entire card. The best
  transformation is probably hash. Typically either pXcardfaceY is
  used, or pXcardfaceYrank / pXcardfaceYsuit, but not both. Valid
  results are a case-insensitive, two character string. The first character
  is the rank and should be one of: &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;, &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;, &#8220;8&#8221;, &#8220;9&#8221;,
  &#8220;t&#8221;, &#8220;j&#8221;, &#8220;q&#8221;, &#8220;k&#8221;, or &#8220;a&#8221;. The second character is the suit and should
  be one of: &#8220;c&#8221;, &#8220;d&#8221;, &#8220;h&#8221; or &#8220;s&#8221;.                                                      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-27-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-27-1"  
class="td11">
 <!--l. 514--><p class="noindent" >p0cardface0rank
  -
  p9cardface0rank </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-27-2"  
class="td11">
 <!--l. 514--><p class="noindent" >The rank of the first card for seats 0-9. The best transformation is
  probably text. Typically either pXcardfaceY is used, or
  pXcardfaceYrank / pXcardfaceYsuit, but not both. Valid results are
  case-insensitive, and are one of &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;, &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;, &#8220;8&#8221;, &#8220;9&#8221;,
  &#8220;10&#8221;, &#8220;t&#8221;, &#8220;j&#8221;, &#8220;q&#8221;, &#8220;k&#8221;, or &#8220;a&#8221;.                                                       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-28-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-28-1"  
class="td11">
 <!--l. 525--><p class="noindent" >p0cardface0suit
  -
  p9cardface0suit </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-28-2"  
class="td11">
 <!--l. 525--><p class="noindent" >The suit of the first card for seats 0-9. The best transformation is
  probably text. Typically either pXcardfaceY is used, or
  pXcardfaceYrank / pXcardfaceYsuit, but not both. Valid results are
  case-insensitive, and are one of &#8220;c&#8221;, &#8220;d&#8221;, &#8220;h&#8221; or &#8220;s&#8221;.                           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-29-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-29-1"  
class="td11">
 <!--l. 531--><p class="noindent" >p0cardface1rank
  -
  p9cardface1rank </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-29-2"  
class="td11">
 <!--l. 531--><p class="noindent" >The rank of the second card for seats 0-9. The best transformation is
  probably text. Typically either pXcardfaceY is used, or
  pXcardfaceYrank / pXcardfaceYsuit, but not both. Valid results are
  case-insensitive, and are one of &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;, &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;, &#8220;8&#8221;, &#8220;9&#8221;,
  &#8220;10&#8221;, &#8220;t&#8221;, &#8220;j&#8221;, &#8220;q&#8221;, &#8220;k&#8221;, or &#8220;a&#8221;. p0cardface1suit - p9cardface1suit The
  suit of the second card for seats 0-9. The best transformation is
  probably text. Typically either pXcardfaceY is used, or
  pXcardfaceYrank / pXcardfaceYsuit, but not both. Valid results are
  case-insensitive, and are one of &#8220;c&#8221;, &#8220;d&#8221;, &#8220;h&#8221; or &#8220;s&#8221;.                           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-30-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-30-1"  
class="td11">
 <!--l. 548--><p class="noindent" >p0dealer -
  p9dealer       </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-30-2"  
class="td11">
 <!--l. 548--><p class="noindent" >Identifies if the dealer button is found for seat 0-9, or not. Color
  transforms are usually used for these regions, but hash, text or image
  transforms can be used too. If the leftmost characters of the result
  from this region&#8217;s transform are either &#8220;true&#8221; or &#8220;dealer&#8221;, then the
  chair is considered to have the dealer button. If any other result is
  returned, such as "false", then the chair is not considered to have the
  dealer button. Results are case-insensitive.                                      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-31-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-31-1"  
class="td11">
 <!--l. 557--><p class="noindent" >p0name -
  p9name        </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-31-2"  
class="td11">
 <!--l. 557--><p class="noindent" >Identifies the name of the player in seat 0-9. It only makes sense to
  use a text transform for these regions.                                           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-32-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-32-1"  
class="td11">
 <!--l. 560--><p class="noindent" >p0seated -
  p9seated      </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-32-2"  
class="td11">
 <!--l. 560--><p class="noindent" >Identifies whether seat 0-9 is occupied (seated) or not. Color
  transforms are usually used for these regions, but hash, text or image
  transforms can be used too. If the leftmost characters of the result
  from this region&#8217;s transform are either &#8220;true&#8221; or &#8220;seated&#8221;, then the
  chair is considered to be seated. If any other result is returned, such
  as "false" or "unseated", then the chair is not considered to be
  seated. Results are case-insensitive.                                               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-33-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-33-1"  
class="td11">
 <!--l. 569--><p class="noindent" >p0chipXY -
  p9chipXY     </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-33-2"  
class="td11">
 <!--l. 569--><p class="noindent" >Note: Chip scraping should *only* be used if the actual numeric bet
  text cannot be found elsewhere on the poker table. Text
  transformation is magnitudes of effort easier to accomplish.
  <!--l. 573--><p class="noindent" >Step 1&#x00A0;: Ensure that the poker site uses static landings for all of the
  chip stacks. Step 2&#x00A0;: Determine the size of an individual chip, and
  should include any portion of the chip that is painted anywhere
  within the window regardless of how faded or transparent. Step 3&#x00A0;:
  Create regions for the initial base of each player&#8217;s chip stacks with the
  size determined in step 2; p0chip00, p1chip00, ..., p9chip00. Step 4&#x00A0;:
  Create vertical stride chip regions for each player&#8217;s chip stack;
  p0chip01, p1chip01, ..., p9chip01. These regions should perfectly
  surround the 2nd chip that rests above the base pXchip00. Step 5&#x00A0;:
  Create horizontal stride chip regions for each player&#8217;s chip stack;
  p0chip10, p1chip10, ..., p9chip10. These regions should perfectly
  surround the base chip in the second stack. Step 6&#x00A0;: Optional and
  rare: If the vertical stride between chips in a stack is not uniform,
  then you will need to define pXchip02-pXchip09 for each chip in the
  stack. For those sites with non-uniform vertical chip strides, this
  means that there is a limit of 10 chips per stack that will be
  recognized by the engine. Step 7&#x00A0;: Optional and rare: If the
  horizontal stride between chip stacks is not uniform, then you will
  need to define pXchip10-pXchip90 for each stack. For those sites with
  non-uniform horizontal chip strides, this means that there is a limit of
  10 stacks that will be recognized by the engine. In a worst case
  situation, there may be 100 chip regions * 10 players = 1000 region
  definitions required to scrape chips! (So now go look at scraping the
  bet text instead)                                                                       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-34-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-34-1"  
class="td11">
 <!--l. 597--><p class="noindent" >u0active -
  u9active       </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-34-2"  
class="td11">
 <!--l. 597--><p class="noindent" >These are alternatives to the p0active-p9active regions, and are used
  for the player&#8217;s seat. They are typically used when the player&#8217;s seat
  changes appearance when it is the player&#8217;s action, to avoid misscrapes
  due to change in color/size, whatever. Any transform can be used
  equally well with this region. If the leftmost characters of the result
  from this region&#8217;s transform are either &#8220;true&#8221; or &#8220;active&#8221;, then the
  region is considered to be active. If any other result is returned, such
  as "false", "inactive", "out" or "away", then the chair is not
  considered to be active. Results are case-insensitive. ubalance,
  u0balance - u9balance These are alternatives to the
  p0balance-p9balance regions, and are used for the player&#8217;s seat. They
  are typically used when the player&#8217;s seat changes appearance when it
  is the player&#8217;s action, to avoid misscrapes due to change in color/size,
  whatever. It only makes sense to use a text transform for these
  regions.                                                                                   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-35-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-35-1"  
class="td11">
 <!--l. 614--><p class="noindent" >u0bet &#8211;
  u9bet          </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-35-2"  
class="td11">
 <!--l. 614--><p class="noindent" >* New Symbol in version 2.0
  <!--l. 616--><p class="noindent" >These are alternatives to the p0bet-p9bet regions, and are used for
  the player&#8217;s seat. They are typically used when the player&#8217;s seat
  changes appearance when it is the player&#8217;s action, to avoid misscrapes
  due to change in color/size, whatever. It only makes sense to use a
  text transform for these regions.                                                   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-36-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-36-1"  
class="td11">
 <!--l. 622--><p class="noindent" >u0cardface0
  -
  u9cardface0  </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-36-2"  
class="td11">
 <!--l. 622--><p class="noindent" >These are alternatives to the p0cardface0-p9cardface0 regions, and
  are used for the player&#8217;s seat. They are typically used when the
  player&#8217;s seat changes appearance when it is the player&#8217;s action, to
  avoid misscrapes due to change in color/size, whatever. Valid results
  are a case-insensitive, two character string. The first character is the
  rank and should be one of: &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;, &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;, &#8220;8&#8221;, &#8220;9&#8221;, &#8220;t&#8221;, &#8220;j&#8221;,
  &#8220;q&#8221;, &#8220;k&#8221;, or &#8220;a&#8221;. The second character is the suit and should be one of:
  &#8220;c&#8221;, &#8220;d&#8221;, &#8220;h&#8221; or &#8220;s&#8221;.                                                                    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-37-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-37-1"  
class="td11">
 <!--l. 638--><p class="noindent" >u0cardface1
  -
  u9cardface1  </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-37-2"  
class="td11">
 <!--l. 638--><p class="noindent" >These are alternatives to the p0cardface1-p9cardface1 regions, and
  are used for the player&#8217;s seat. They are typically used when the
  player&#8217;s seat changes appearance when it is the player&#8217;s action, to
  avoid misscrapes due to change in color/size, whatever. Valid results
  are a case-insensitive, two character string. The first character is the
  rank and should be one of: &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;, &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;, &#8220;8&#8221;, &#8220;9&#8221;, &#8220;t&#8221;, &#8220;j&#8221;,
  &#8220;q&#8221;, &#8220;k&#8221;, or &#8220;a&#8221;. The second character is the suit and should be one of:
  &#8220;c&#8221;, &#8220;d&#8221;, &#8220;h&#8221; or &#8220;s&#8221;.                                                                    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-38-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-38-1"  
class="td11">
 <!--l. 654--><p class="noindent" >u0dealer &#8211;
  u9dealer       </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-38-2"  
class="td11">
 <!--l. 654--><p class="noindent" >* New Symbol in version 2.0
  <!--l. 656--><p class="noindent" >These are alternatives to the p0dealer-p9dealer regions, and are used
  for the player&#8217;s seat. They are typically used when the player&#8217;s seat
  changes appearance when it is the player&#8217;s action, to avoid misscrapes
  due to change in color/size, whatever. Color transforms are usually
  used for these regions, but hash, text or image transforms can be used
  too. If the leftmost characters of the result from this region&#8217;s
  transform are either &#8220;true&#8221; or &#8220;dealer&#8221;, then the chair is considered to
  have the dealer button. If any other result is returned, such as
  "false", then the chair is not considered to have the dealer button.
  Results are case-insensitive.                                                         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-39-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-39-1"  
class="td11">
 <!--l. 668--><p class="noindent" >uname,
  u0name -
  u9name        </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-39-2"  
class="td11">
 <!--l. 668--><p class="noindent" >These are alternatives to the p0name-p9name regions, and are used
  for the player&#8217;s seat. They are typically used when the player&#8217;s seat
  changes appearance when it is the player&#8217;s action, to avoid misscrapes
  due to change in color/size, whatever. It only makes sense to use a
  text transform for these regions.                                                   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-40-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-40-1"  
class="td11">
 <!--l. 674--><p class="noindent" >u0seated -
  u9seated      </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-40-2"  
class="td11">
 <!--l. 674--><p class="noindent" >These regions are alternatives to the p0seated-p9seated regions, and
  are used for the player&#8217;s seat. They are typically used when the
  player&#8217;s seat changes appearance when it is the player&#8217;s action, to
  avoid misscrapes due to change in color/size, whatever. Color
  transforms are usually used for these regions, but hash, text or image
  transforms can be used too. If the leftmost characters of the result
  from this region&#8217;s transform are either &#8220;true&#8221; or &#8220;seated&#8221;, then the
  chair is considered to be seated. If any other result is returned, such
  as "false" or "unseated", then the chair is not considered to be
  seated. Results are case-insensitive.                                               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-41-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-41-1"  
class="td11">
 <!--l. 686--><p class="noindent" >tablepointNNN </td><td  style="white-space:wrap; text-align:left;" id="TBL-2-41-2"  
class="td11">
 <!--l. 686--><p class="noindent" >These regions are used when the "Green Circle Button" is clicked on
  the OpenHoldem toolbar to "automagically" find a table to connect
  to. These regions must be one pixel wide by one pixel tall and must
  use a color transform. All tablepoint records must match the pixel
  colors on the casino window for it to be recognized on a connect. See
  {How the &#8220;Green Circle Button&#8221; finds tables} for more details.           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-42-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-42-1"  
class="td11">            </td>

</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-43-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-43-1"  
class="td11">            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-44-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-44-1"  
class="td11">
 <!--l. 694--><p class="noindent" >           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-45-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-45-1"  
class="td11">
 <!--l. 694--><p class="noindent" >           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-46-"><td  style="white-space:wrap; text-align:left;" id="TBL-2-46-1"  
class="td11">
 <!--l. 694--><p class="noindent" >           </td>
   </tr>
   </table></div>
    
</body></html> 



