#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass amsbook
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
\begin_inset Index
status open

\begin_layout Plain Layout
Automation
\end_layout

\end_inset

Automation
\begin_inset CommandInset label
LatexCommand label
name "cha:Automation"

\end_inset


\end_layout

\begin_layout Standard
Alright, so you have made it through the previous sections, and have a working
 Table Map, a set of bot logic for your target game, and a fully-stealthed
 out configuration.
 You may have just started to realize what a pain it is to have to manually
 start the software, select a table, sit at the table, connect OpenHoldem,
 leave the table, start a new table, etc.
 This becomes even more oppressive if you want to run multiple simultaneous
 tables.
\end_layout

\begin_layout Standard
The answer is automation.
 Automation will do these opening, selecting, moving, and clicking activities
 for you, and allow you to ultimately sleep while your poker bot plays for
 you.
 Nothing better than making money while you sleep!
\end_layout

\begin_layout Section
\begin_inset Index
status open

\begin_layout Plain Layout
AutoIT
\end_layout

\end_inset

AutoIT
\begin_inset CommandInset label
LatexCommand label
name "sec:AutoIT"

\end_inset


\end_layout

\begin_layout Standard
The general tool of choice for automation is AutoIt
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://autoitscript.com
\end_layout

\end_inset


\end_layout

\end_inset

.
 AutoIt is a free (as in beer – this is not an open source program) Windows
 scripting language and execution engine.
 From the web site: “AutoIt is a freeware Windows automation language.
 It can be used to script most simple Windows-based tasks (great for PC
 rollouts or home automation).
 AutoIt has been in popular use since 1999 and continues to provide users
 and administrators with an easy way to script the Windows GUI.
 In February 2004 the latest version of AutoIt - known as AutoIt v3 - was
 released and added powerful scripting features.”
\end_layout

\begin_layout Standard
Automation of poker botting is one of those “simple Windows-based tasks”
 that AutoIt is great for.
 The challenge is that now you have a new language to learn (does it ever
 end?), but the support for AutoIt on their forums is astounding, and you
 can also get help on the OpenHoldem forums.
 
\end_layout

\begin_layout Section
\begin_inset Index
status open

\begin_layout Plain Layout
Scout
\end_layout

\end_inset

Scout - A Hopper
\end_layout

\begin_layout Standard
As a starting point could serve the “Scout” hopper (hopper is the name generally
 given to AutoIt scripts that automatically start and connect poker windows
 for you)
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://scout-poker-bot-hopper.googlecode.com/files/Scout2.68.zip
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Scout will not work out of the box, guaranteed, but it can serve as a possible
 starting point for your script for your casino.
 This is an important point – hoppers, like Table Maps, are very specific
 to a given casino.
 Think about the actions you take to join a table on different casinos –
 the actions to do that all differ ever so slightly! 
\end_layout

\begin_layout Section
Connect By 
\begin_inset Index
status open

\begin_layout Plain Layout
HWND
\end_layout

\end_inset

HWND
\end_layout

\begin_layout Standard
Version 2.0.0 of OpenHoldem introduced the ability to instruct OpenHoldem
 to connect to a poker table by sending a connect message specifying a HWND
\begin_inset Foot
status open

\begin_layout Plain Layout
ddd
\end_layout

\end_inset

.
 This is useful for automation reasons and permits you to explicitly control
 the connection process without having to display the OpenHoldem attach
 window.
 In fact, you can have OpenHoldem hidden entirely during this process.
\end_layout

\begin_layout Standard
Example AutoIt Script
\end_layout

\begin_layout Standard

\noun on
#include <WinAPI.au3> 
\end_layout

\begin_layout Standard

\noun on
Func AttachOH($OHhwnd,$POKERhwnd) 
\end_layout

\begin_layout Standard

\noun on
_SendMessage($OHhwnd, 0x8002, 0, $POKERhwnd ) 
\end_layout

\begin_layout Standard

\noun on
Return 
\end_layout

\begin_layout Standard

\noun on
EndFunc
\end_layout

\begin_layout Section
\begin_inset Index
status open

\begin_layout Plain Layout
command line
\end_layout

\end_inset

Command Line Options 
\end_layout

\begin_layout Standard
Version 2.0.0 of OpenHoldem introduced the ability to instruct OpenHoldem
 to use 
\begin_inset Index
status open

\begin_layout Plain Layout
ini-file
\end_layout

\end_inset

.ini files for storage of preferences, rather than using the registry.
 This is beneficial for two reasons: 
\end_layout

\begin_layout Itemize
\begin_inset Index
status open

\begin_layout Plain Layout
Stealth
\end_layout

\end_inset

Stealth: .ini files are easier to hide than the 
\begin_inset Index
status open

\begin_layout Plain Layout
registry
\end_layout

\end_inset

registry.
\end_layout

\begin_layout Itemize
Portability: .ini files can easily be deployed and moved from machine to
 machine.
\end_layout

\begin_layout Subsection
Using the .ini-file
\end_layout

\begin_layout Standard
To specify the use of .ini files for preferences, rather than the registry,
 there are three options: “/ini” specifies the use of openholdem.ini, created
 in the OpenHoldem startup directory “/ini:[filepath]” specfies the use
 of [filename] as the ini file, must be a full path “/ini:~
\backslash
[filename]” specifies the use of [filename] in the OpenHoldem startup directory
 as the ini file.
\end_layout

\begin_layout Subsection
Creating the .ini-file
\end_layout

\begin_layout Standard
To create the .ini-file the first time start OpenHoldem with the 
\begin_inset Quotes eld
\end_inset

/ini
\begin_inset Quotes erd
\end_inset

-parameter at the command-line, then open the preferences, click through
 all tabs and finally confirm with 
\begin_inset Quotes eld
\end_inset

OK
\begin_inset Quotes erd
\end_inset

.
 OpenHoldem will then save all settings to the file instead of storing them
 in the registry.
\end_layout

\begin_layout Section
Avoid 
\begin_inset Index
status open

\begin_layout Plain Layout
race-condition
\end_layout

\end_inset

race-conditions
\end_layout

\begin_layout Standard
race-co.
\begin_inset Foot
status open

\begin_layout Plain Layout
bbb
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OpenHoldem will take care of that problem automatically; it will synchronize
 the autoplayer-actions of all instances, including actions taken by the
 rebuy-function and by the chat-function.
 It uses a system-wide 
\begin_inset Index
status open

\begin_layout Plain Layout
mutex
\end_layout

\end_inset

mutex to ensure exclusive access to the keyboard and the mouse.
 Unfortunatelly OpenHoldem is not the only program, which uses that resources;
 usually the hopper competes for them, too.
\end_layout

\begin_layout Standard
So any good hopper should wait with its actions, until OpenHoldem has finished
 its input; it has to implement the same protection-mechanism and wait for
 the same mutex.
 The default name of that mutex is 
\begin_inset Quotes eld
\end_inset

OHAntiColl
\begin_inset Quotes erd
\end_inset

, but it can be changed in the preferences to your liking.
\end_layout

\begin_layout Standard
An example AutoIT-hopper-code has been provided by USBFreak
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.maxinmontreal.com/wiki/index.php5?title=System_Wide_Mutex_Handling_-_Sam
ple_Code
\end_layout

\end_inset


\end_layout

\end_inset

:
\end_layout

\begin_layout Quotation
========================================
\end_layout

\begin_layout Quotation
System Wide Mutex Handling - Sample Code
\end_layout

\begin_layout Quotation
Below are 3 functions you'll need if you plan to avoid OH and hopper "collisions
" over mouse and keyboard inputs.
 As you may know, OH ensures it can act on the table in a consistent manner
 by seizing control of mouse / keyboard input (system wide mutex), performing
 its actions (clicking buttons, entering text in swag field etc.) and then
 releasing mutex so other applications can perform their tasks.
\end_layout

\begin_layout Quotation
This works fine as long as you run one or few OH instances, and do not have
 a very active hopper to manage them.
 Once you are past that point and start running many tables with as many
 OH instances, plus moving tables around, browsing lobby etc., a situation
 where OH may interfere with hopper operations in the middle of an important
 task occurs, resulting in very unpredictable behaviour.
\end_layout

\begin_layout Quotation
To avoid such a possibility, you may want to implement mutex handling in
 your hopper using below code.
\end_layout

\begin_layout Quotation
The idea:
\end_layout

\begin_layout Enumerate
Create mutex lock at the start of your hopper.
 This seizes control of keyboard / mouse and no other application can send
 any input using them until mutex is released/unlocked.
 
\end_layout

\begin_layout Enumerate
Find a good time in your hopper loop when game state is stable (no lobby
 browsing, table opening / closing etc.) and release mutex for a period of
 time (in my case this is (number of OH instances opened * 1) + 2 seconds).
 This allows OH instances to grab mutex control for themselves, perform
 any pending actions, and release mutex control again.
 
\end_layout

\begin_layout Enumerate
Once the predetermined period of time expires, create mutex lock again,
 and proceed with hopper operations knowing nothing can interfere with mouse
 / keyboard.
 
\end_layout

\begin_layout Enumerate
At the end of your hopper, release/unlock mutex.
 
\end_layout

\begin_layout Standard
Main hopper loop
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

;
\lang english
START YOUR HOPPER, CREATE MUTEX LOCK 
\end_layout

\begin_layout Plain Layout
MutexLock() $Global_Mutex_Handle = _CreateMutex("OHAntiColl") 
\end_layout

\begin_layout Plain Layout
;ENTERING HOPPER LOOP 
\end_layout

\begin_layout Plain Layout
While (1) 
\end_layout

\begin_layout Plain Layout

    
\lang english
;...
 HOPPER OPERATIONS 
\end_layout

\begin_layout Plain Layout

    
\lang english
;...
 GAME STATE STABLE, UNLOCK MUTEX 
\end_layout

\begin_layout Plain Layout

    
\lang english
MutexUnlock($Global_Mutex_Handle) 
\end_layout

\begin_layout Plain Layout

    
\lang english
;...
 WAIT FOR OH TO PERFORM ACTIONS 
\end_layout

\begin_layout Plain Layout

    
\lang english
;...
 TIME EXPIRED, CREATE MUTEX LOCK AGAIN 
\end_layout

\begin_layout Plain Layout

    
\lang english
MutexLock() 
\end_layout

\begin_layout Plain Layout
wend 
\end_layout

\begin_layout Plain Layout
;END OF HOPPER, RELEASE MUTEX 
\end_layout

\begin_layout Plain Layout
MutexUnlock($Global_Mutex_Handle) 
\end_layout

\begin_layout Plain Layout
;END OF HOPPER, CLOSE MUTEX HANDLE 
\end_layout

\begin_layout Plain Layout
Close_Mutex_Handle($Global_Mutex_Handle)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hopper functions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
Func _CreateMutex($sOccurenceName) 
\end_layout

\begin_layout Plain Layout

    
\lang english
Local $ERROR_ALREADY_EXISTS = 183 
\end_layout

\begin_layout Plain Layout

    
\lang english
$Global_Mutex_Handle = DllCall("kernel32.dll", 
\end_layout

\begin_layout Plain Layout

        
\lang english
"int", "CreateMutex", "int", 0, 
\end_layout

\begin_layout Plain Layout

        
\lang english
"long", 1, "str", $sOccurenceName) 
\end_layout

\begin_layout Plain Layout

    
\lang english
$lastError = DllCall("kernel32.dll", "int", "GetLastError") 
\end_layout

\begin_layout Plain Layout

    
\lang english
If $lastError[0] = $ERROR_ALREADY_EXISTS Then 
\end_layout

\begin_layout Plain Layout

        
\lang english
Return SetError($lastError[0], $lastError[0], 
\end_layout

\begin_layout Plain Layout

            
\lang english
$Global_Mutex_Handle[0]) 
\end_layout

\begin_layout Plain Layout

    
\lang english
EndIf 
\end_layout

\begin_layout Plain Layout

    
\lang english
Return SetError(0, 0, $Global_Mutex_Handle[0]) 
\end_layout

\begin_layout Plain Layout
EndFunc ;==>_GetMutex
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Func MutexUnlock($Global_Mutex_Handle)        
\end_layout

\begin_layout Plain Layout

    Local $releasemutex = DllCall("kernel32.dll", "int", 
\end_layout

\begin_layout Plain Layout

        "ReleaseMutex", "long", $Global_Mutex_Handle)        
\end_layout

\begin_layout Plain Layout

    Return (IsArray($releasemutex) And $releasemutex[0] > 0)  
\end_layout

\begin_layout Plain Layout

EndFunc   ;==>_ReleaseMutex
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Func Close_Mutex_Handle($hMutex)        
\end_layout

\begin_layout Plain Layout

    Local $aCH = DllCall("Kernel32.dll", "int", 
\end_layout

\begin_layout Plain Layout

        "CloseHandle", "hwnd", $Global_Mutex_Handle)        
\end_layout

\begin_layout Plain Layout

    Return (IsArray($aCH) And $aCH[0] > 0)    
\end_layout

\begin_layout Plain Layout

EndFunc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Func _API_WaitForSingleObject($Global_Mutex_Handle, $dwMilliseconds)
\end_layout

\begin_layout Plain Layout

    Local $aResult = DllCall("kernel32.dll", "long", 
\end_layout

\begin_layout Plain Layout

        "WaitForSingleObject", "long", $Global_Mutex_Handle, 
\end_layout

\begin_layout Plain Layout

        "long", $dwMilliseconds)        
\end_layout

\begin_layout Plain Layout

    Return $aResult[0]    
\end_layout

\begin_layout Plain Layout

EndFunc   ;==>_API_WaitForSingleObject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Func MutexLock()        
\end_layout

\begin_layout Plain Layout

    While 1                
\end_layout

\begin_layout Plain Layout

        $Global_Mutex_Handle = _CreateMutex("OHAntiColl");             
   
\end_layout

\begin_layout Plain Layout

        If @error = 0 Then                        
\end_layout

\begin_layout Plain Layout

            ;SUCCESSFULLY CREATED AND LOCKED MUTEX                     
   
\end_layout

\begin_layout Plain Layout

            ExitLoop                
\end_layout

\begin_layout Plain Layout

        Else                        
\end_layout

\begin_layout Plain Layout

            ;WE WILL EXAMINE MUTEX TO SEE IF IT IS RELEASED   
\end_layout

\begin_layout Plain Layout

            Local $result = _API_WaitForSingleObject(
\end_layout

\begin_layout Plain Layout

                $Global_Mutex_Handle, 30000); 
\end_layout

\begin_layout Plain Layout

            WAIT FOR MUTEX FOR 30 SECONDS                        
\end_layout

\begin_layout Plain Layout

            If $result = 0 Or $result = 128 Then
\end_layout

\begin_layout Plain Layout

                ;SUCCESSFULLY LOCKED MUTEX                             
   
\end_layout

\begin_layout Plain Layout

                ExitLoop                      
\end_layout

\begin_layout Plain Layout

            EndIf                
\end_layout

\begin_layout Plain Layout

        EndIf                
\end_layout

\begin_layout Plain Layout

        ;WAIT A BIT BEFORE TRYING AGAIN
\end_layout

\begin_layout Plain Layout

        ;WE ARE NOT PROCEEDING UNTIL WE HAVE CONTROL OF MUTEX          
      
\end_layout

\begin_layout Plain Layout

        Sleep(100)        
\end_layout

\begin_layout Plain Layout

    WEnd    
\end_layout

\begin_layout Plain Layout

EndFunc ;==>MutexLock
\end_layout

\end_inset


\end_layout

\begin_layout Section
Rebuys
\end_layout

\begin_layout Standard
OpenHoldem contains now the ability to control 
\begin_inset Index
status open

\begin_layout Plain Layout
rebuy-script
\end_layout

\end_inset

rebuy-scripts with the bot.
\end_layout

\begin_layout Standard
OpenHoldem will then aquire the autoplayer-mutex to avoid mouse- and keyboard-co
llisions with other instances of OpenHoldem.
 After all those safety-measures have been taken the autoplayer will call
 the rebuy-script, an external executable, that can be specified in the
 preferences.
 OpenHoldem will pass the necessary information as command-line-parameters
 to the rebuy-script.
 Everything inside the script is very specific to the casino, so it is left
 to the user.
 See 
\begin_inset Quotes eld
\end_inset

RebuyDemo
\begin_inset Quotes erd
\end_inset

 in the source-tree for a very small AutoIT-script, that could serve as
 a starting-point.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features>
<column alignment="center" valignment="top" width="50text%">
<column alignment="center" valignment="top" width="50text%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="1">
<features>
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Commandline-parameters
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Casino (name)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Windowhandle of the pokertable (HWND)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UserChair (0-9)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Balance (in dollars)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Smallblind (in dollars)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bigblind (in dollars)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bigbet (in dollars)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Target-amount (in dollars)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../Images/Automatisation/RebuyParameters.jpg

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Connecting To A Table
\end_layout

\begin_layout Subsection
Automatic reconnection
\end_layout

\begin_layout Section
Setting process CPU affinity - Sample Code 
\end_layout

\begin_layout Standard
In some cases it may be beneficial to force poker client process to work
 off one CPU in multiprocessor machines (or dual VCPU VMs).
 Good example is OnGame, which uses much more CPU on dual CPU machines than
 on single CPU machines.
 This is of course problem with their software but they are unlikely to
 fix it.
\end_layout

\begin_layout Standard
The downside is that poker software operations (browsing lobby, updates,
 table management, etc.) are now forced to work with one CPU, so multitabling
 (4+) may be taxing CPU0 - make sure to observe behaviour with and without
 forcing affinity, and draw your own conclusions.
\end_layout

\begin_layout Standard
Here is the code that will set poker client exe CPU affinity to CPU0 (first
 CPU): Only one process should exist, $PokerClient_Exe is your lobby
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
Local $PIDs = ProcessList($PokerClient_Exe) 
\end_layout

\begin_layout Plain Layout
Local $OpenProcessHandle = _WinAPI_OpenProcess(
\end_layout

\begin_layout Plain Layout

    
\lang english
$PROCESS_QUERY_INFORMATION+$PROCESS_SET_INFORMATION, False, $PIDs[1][1])
 
\end_layout

\begin_layout Plain Layout
Local $Process_Affinity_Before_Setting = _WinAPI_GetProcessAffinityMask(
\end_layout

\begin_layout Plain Layout

    
\lang english
$OpenProcessHandle) 
\end_layout

\begin_layout Plain Layout
;MsgBox(0,
 
\lang english
"Affinity Before Setting", $Process_Affinity_Before_Setting, 3)
\end_layout

\begin_layout Plain Layout
_WinAPI_SetProcessAffinityMask($OpenProcessHandle, 0x01)
\end_layout

\begin_layout Plain Layout
$Process_Affinity_After_Setting =
 
\lang english
_WinAPI_GetProcessAffinityMask(
\end_layout

\begin_layout Plain Layout

    
\lang english
$OpenProcessHandle) 
\end_layout

\begin_layout Plain Layout
;MsgBox(0,"Affinity After Setting", $Process_Affinity_After_Setting, 3)
 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
