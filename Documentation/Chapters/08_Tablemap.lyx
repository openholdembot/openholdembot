#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass amsbook
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Creating a Table Map
\end_layout

\begin_layout Standard
Creating a Table Map is not a difficult process, once you get the hang of
 it, but it does have a steep learning curve.
 The benefit is that once you learn how to create maps, you can quite quickly
 take your bot to any casino on the Internet.
\end_layout

\begin_layout Standard
OpenScrape is the program that is used to create Table Maps.
 It provides a graphical interface to provide a set of parameters that are
 stored in human-readable text files with the .tm extension.
 Try it – open any .tm file in Notepad and you can quite clearly see the
 way the file is laid out.
 Each Table Map has a set of parameters, grouped by record type.
 The following sections will discuss how to use each of these record types
 to create your map.
\end_layout

\begin_layout Section
First thing’s first: connect to the poker window
\end_layout

\begin_layout Standard
Start a casino, and open up a play money table.
 You can even use “observer” mode for this activity if you like.
 Alternatively, once you learn how to use saved frames and OHReplay, you
 can also connect OpenScrape to these saved frames while offline from the
 casino.
\end_layout

\begin_layout Standard
For now, let’s keep it simple.
 Once you have a poker table setup, startup the OpenScrape program from
 the “c:
\backslash
mpb” directory that you set up above.
 Arrange the casino table window and the OpenScrape windows on your screen
 in such a way that there is no overlap – OpenScrape needs a clear view
 of the poker table window to do its job.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_ArrangedWindows.bmp

\end_inset


\end_layout

\begin_layout Standard
Connect OpenScrape to the casino table by clicking on the Green Circle Button
 on the OpenScrape toolbar.
 A dialog with a list of top-level windows that are currently visible on
 your screen will appear.
 Select the one from the list that matches your casino table, and select
 OK.
 (Note, in this screenshot, we are connecting to a “ManualMode” window.
 You will learn more about ManualMode later in this document, but for now,
 just consider ManualMode to be a simulated, offline poker table).
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_WindowSelection.bmp

\end_inset


\end_layout

\begin_layout Standard
A static image of the poker table window will be displayed in OpenScrape’s
 main window.
 Once OpenScrape has the poker table’s image displayed, you can minimize
 the poker table if you want, to give yourself more room to work.
 As the casino table changes state, and if you want to update the image
 that is displayed in the OpenScrape main window, you can do so at any time
 by clicking on the refresh button on the toolbar (Black and White arrows),
 or by choosing View/Refresh from the menu.
 When a refresh is requested, OpenScrape will bring the connected window
 to the front, grab the image, and then place it to the back again.
 Additionally, if you have OpenScrape connected to an OHReplay window, it
 automatically moves OHReplay to the next saved frame prior to grabbing
 the image.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_Connected.bmp

\end_inset


\end_layout

\begin_layout Standard
Once we have the poker table image in OpenScrape, it is time to start building
 our Table Map, and providing the parameters that the OpenHoldem game state
 engine will use to “read” the poker table.
 
\end_layout

\begin_layout Section
Familiarizing yourself with OpenScrape
\end_layout

\begin_layout Standard
When you started the OpenScrape program, two windows appeared.
 The “Main” window has the menu bar, the toolbar, and a display of the poker
 table image.
 The other window that appeared is the “TableMap Editor” window, and is
 where you will be doing most of your work with OpenScrape.
 The “TableMap Editor” window does not have a menu or toolbar, and has “TableMap
” as its title.
\end_layout

\begin_layout Subsection
Main: Menu Options
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_FileMenu.bmp

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_EditMenu.bmp

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_ViewMenu.bmp

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The File menu contains the standard Windows options to open and save Table
 Map files.
\end_layout

\begin_layout Standard
The Edit menu contains the standard Windows options, plus two options specific
 to OpenScrape:
\end_layout

\begin_layout Itemize
Update Hashes: This option will recalculate all the Hash records in the
 current map – useful if you have made changes to the underlying images,
 for example.
 More on Hashes later.
 
\end_layout

\begin_layout Itemize
Duplicate Region: This option will allow you to easily duplicate Regions.
 For example, once you have the player 1 card locations defined, you might
 want to copy those to players 2-10 to make things easier on yourself.
 More on Regions later.
\end_layout

\begin_layout Standard
The View menu has the standard Windows Toolbar/Status Bar options, plus
 the following specific OpenScrape options:
\end_layout

\begin_layout Itemize
Connect To Window: This option duplicates the “Green Circle Button” on the
 toolbar, and will bring up a dialog to allow you to select which window
 OpenScrape will copy an image from.
 
\end_layout

\begin_layout Itemize
Show Region Boxes: Allows you to toggle whether or not Region boxes are
 displayed on top of the poker table image in the main window.
 
\end_layout

\begin_layout Itemize
Refresh: This option duplicates the Black and White Arrow button on the
 toolbar, and will copy to current casino table image to the OpenScrape
 main window.
 
\end_layout

\begin_layout Itemize
Group Regions/Ungroup Regions: These options allow for customization of
 how Region records are displayed in the Table Map Editor window.
 
\end_layout

\begin_layout Itemize
Current size: Displays the client size of the window that OpenScrape is
 currently attached to.
 This is very useful when creating certain String records.
 
\end_layout

\begin_layout Subsection
Main: Toolbar 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_MainTollbar.bmp

\end_inset


\end_layout

\begin_layout Standard
The toolbar on the main window performs the following actions, from left
 to right: New Table Map Open Table Map Save Table Map Connect to window
 Toggle Region box display on or off Refresh the poker table image Display
 Help/About Note: Keyboard shortcuts exist for many of these menu options
 and toolbar buttons, in addition to the standard Windows keyboard shortcuts:
 F1 – Help/About F3 – Connect to window F4 – Toggle Region box display on
 or off F5 – Refresh the poker table image Control + U – Update Hashes Table
 Map: Buttons/fields The Table Map Editor window has a plethora of information
 on it, and various fields and controls will become enabled or disabled,
 depending on the type of map record selected.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_TmEditorWindow.bmp

\end_inset


\end_layout

\begin_layout Standard
On the top left of the window are three buttons, New/Delete/Edit, that allow
 you to add new records to the map, remove records from the map, or edit
 records in the map.
 The “New” button will prompt you to add a record of the type that is selected
 in the tree display directly below.
 For example, if you have a Region record selected, clicking New will prompt
 you to add a new region record to the map.
 The “Delete” and “Edit” buttons operate on the currently selected record.
\end_layout

\begin_layout Standard
Directly below the New/Edit/Delete buttons is the record tree display.
 This box displays all records that are currently present in the map, and
 groups them by type.
 The Region records within this tree can be further sub-grouped using the
 View menu options on the main window.
 There are a number of choices for sub-grouping Region records, and are
 intended to improve the productivity of Table Map creation.
 Experimentation of these sub-groupings is necessary to see if any meet
 your personal needs.
\end_layout

\begin_layout Standard
Below the tree display is a drop down to select the zoom level of the image
 that is displayed in the big box on the bottom right portion of the window.
 The image displayed is dependent on the record type selected.
\end_layout

\begin_layout Standard
Below the Zoom Level are various drop downs that are used to serve as checklists
 for capturing fonts and card images.
 Capturing fonts and card images will be discussed later.
\end_layout

\begin_layout Standard
On the top right of this window are a large group of controls, there is
 a “Rectangle” group, a “Nudge” group, and “Transform”, “Radius”, “Color”,
 “Avg Color” , and “Result” fields.
 These controls are used mainly for setting the parameters of Region records,
 and are only enabled when a Region record is selected in the record tree
 display on the left side of the window.
 The meaning of these fields will be described in the “Region” record section
 below.
 Some of these fields may display other relevant information, depending
 on the record type selected in the display tree.
\end_layout

\begin_layout Standard
Below this large group of controls are buttons to create Hash records, Font
 records and Image records.
 These buttons will be enabled/disabled appropriately depending on the record
 type that is selected in the display tree.
 For example, creating an Image record only makes sense if a Region record
 is selected in the display tree.
 Creating a Font record only make sense if a Region record with a text transform
 type is selected in the display tree.
\end_layout

\begin_layout Standard
The box below the Hash, Font and Image buttons is used to display “pixel
 separation”.
 The “+” and “-“ buttons to the right of this box control the size of the
 font used in this box.
 Pixel separation is used for regions that use font transforms.
 A good separation between foreground and background colors is imperative
 for good font recognition, and this box lets you preview that separation.
 
\end_layout

\begin_layout Section
Size Records 
\end_layout

\begin_layout Subsection
Description 
\end_layout

\begin_layout Standard
Size records are used for one purpose only, to allow OpenHoldem’s “Green
 Circle Button” to find windows of the correct size.
 More specifically, they provide the ability to specify the accepted sizes
 for the casino table that the scraper engine will recognize.
 Upon a click of the “Green Circle Button”, OpenHoldem will first search
 for poker table windows that match the exact size (clientsize) and if no
 match is found, will then look for poker table windows that are between
 the clientsizemin and clientsizemax sizes.
 In the majority of Table Maps, the only size record that is needed is the
 clientsize record.
 Use of clientsizemin and clientsizemax records should only be considered
 in unusual and exceptional cases.
 Manipulating size records using OpenScrape To create a new size record,
 select the “Sizes” category in the record tree display on the Table Map
 Editor window, and click the “New” button.
 A window will be displayed that allows you to enter the width and height
 parameters for this new record.
 To edit an existing size record, select the record in the record tree display
 on the Table Map Editor window, and click the “Edit” button.
 A window will be displayed that allows you to adjust the width and height
 parameters for this record, or change the record name itself.
 To delete an existing size record, select the record in the record tree
 display on the Table Map Editor window, and click the “Delete” button.
 A window will be displayed asking for verification of this action.
\end_layout

\begin_layout Standard
A note about window client sizes: Microsoft Windows provides several different
 measures of a windows’ size, such as the complete window including frame
 and title bar, and an altogether different measure, the so-called “client
 area”, that lies inside the window frame and excludes frames and title
 bars.
 OpenHoldem references the Microsoft “client area” measurement for these
 “Size” records.
 To help you understand the size of the poker window that you have attached
 to (with the Green Circle Button), OpenScrape always displays the client
 size of the attached poker table in the “View” menu on the main OpenScrape
 window.
 The menu option is at the bottom of this menu and is preceeded by “Current
 Size: “.
 The width and height displayed in this menu can be entered directly into
 a clientsize record.
 
\end_layout

\begin_layout Subsection
Technical reference 
\end_layout

\begin_layout Standard
In the Table Map (.tm) file, these records will be preceded with the characters
 "z$”.
 Size records have the following format: 
\end_layout

\begin_layout Standard
z$<name> <width> <height>
\end_layout

\begin_layout Standard
<name> is the name of the record (see table below) <width> and <height>
 are integer values.
 
\end_layout

\begin_layout Standard
Valid size records and their descriptions: Record Description clientsize
 Specifies the exact client size of the poker table window.
 clientsizemin Specifies the minimum allowed client size of the poker table
 window.
 clientsizemax Specifies the maximum allowed client size of the poker table
 window.
\end_layout

\begin_layout Section
Symbol Records 
\end_layout

\begin_layout Standard
Description Symbol records are a general purpose record type that serves
 many different purposes within OpenHoldem and OpenScrape.
 The common characteristic of these records is that they all contain a name
 and a free-form text field.
 The interpretation of that text field is different, depending on the name
 of the symbol record.
 The table in the technical reference section below describes how the free-form
 text is interpreted for each different Symbol record type.
 Manipulating symbol records using OpenScrape To create a new symbol record,
 select the “Symbols” category in the record tree display on the Table Map
 Editor window, and click the “New” button.
 A window will be displayed that allows you to enter the free-form text
 for this new record.
 To edit an existing symbol record, select the record in the record tree
 display on the Table Map Editor window, and click the “Edit” button.
 A window will be displayed that allows you to adjust the free-form text
 for this record, or change the record name itself.
 To delete an existing symbol record, select the record in the record tree
 display on the Table Map Editor window, and click the “Delete” button.
 A window will be displayed asking for verification of this action.
\end_layout

\begin_layout Standard
Note: The Insert and Delete keys can also be used as a shortcut for adding
 and deleting Symbol records.
\end_layout

\begin_layout Standard
In the case of the “New” and “Edit” actions, the window that pops up also
 contains a field for “Titlebar text”, a button to parse the title bar text,
 and a field to display the parse results.
 These three controls are only relevant if the record name is one of the
 ttlimits types.
 If a ttlimits record type is selected, these fields will be enabled, otherwise
 they will be grayed out.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_NewEditWindow.bmp

\end_inset


\end_layout

\begin_layout Standard
These three fields allow you to test the parsing of the window’s title bar
 text with the parse string that is specified in the “String” field, and
 see the results of this parse in the results field at the bottom of the
 window.
 The “Titlebar text” field is initially populated with the titlebar text
 of the window that OpenScrape is attached to (via the “Green Circle Button”),
 but this text can be overridden with anything you want to test parse.
\end_layout

\begin_layout Standard
Technical Reference In the Table Map (.tm) file, these records will be preceded
 with the characters "s$".
 Symbol records have the following format: 
\end_layout

\begin_layout Standard
s$<name> <text> 
\end_layout

\begin_layout Standard
<name> is the name of the record (see table below) <text> is the content
 of the record 
\end_layout

\begin_layout Standard
Valid symbol records and their descriptions: Record Description titletext,
 titletext0 - titletext9 When the “Green Circle Button” is pressed, OpenHoldem
 will look through each of these symbols and do a partial match of <text>
 to each window’s title bar text.
 If any substring provided in any of these symbols matches, then the window
 is considered a match.
 !titletext,  !titletext0 -!titletext9 When the “Green Circle Button” is
 pressed, OpenHoldem will look through each of these symbols and do a partial
 match of <text> to each window’s title bar text.
 If all substrings provided in all of these symbols do not match, then the
 window is considered a match.
 ttlimits, ttlimits0 - ttlimits9 These symbols are intended to provide a
 format string that is used to parse the window's titlebar text, and extract
 sblind, bblind, bigbet, ante and game type information.
 The syntax usage of the format string is very much like the standard C-language
 format strings for scanf and printf.
 The placeholders use the caret character as the indicator and have the
 following meanings: ^h hand number ^d dummy integer (read chars 0-9 only)
 ^f dummy float (read chars 0-9 including decimal '.') ^s sblind ^b bblind
 ^B bigbet ^a ante ^v sb or bb depending on limit type ^V bb or BB depending
 on limit type ^* skip all text up to the literal character following the
 * ^R roman numeral as in "Level VIII" as typically seen in SNGs ^L limit
 indicator 
\end_layout

\begin_layout Standard
For the integer and float numerics, the scanner will automatically accept
 and skip a leading dollar sign “$” or leading/trailing cent sign “¢” (ascii
 162 hex a2).
 In the case of the cent sign the target number will be divided by 100.
 The scanner will also recognize the standard trailing metric unit multipliers
 of “k” and “m” (1000 and 1000000 respectively).
 
\end_layout

\begin_layout Standard
The following case-insensitive strings are recognized for the ^L limit indicator
: no limit, no-limit, nolimit, nl pot limit, pot-limit, potlimit, pl fixed
 limit, fixed-limit, fixedlimit, fl, limit 
\end_layout

\begin_layout Standard
As an example, this title bar text "NL SNG Level VI 25/50 (2)" could be
 parsed with this format string "^L SNG Level ^R ^s/^b (^a)" to result in
 the sblind, bblind and game type being recognized.
 
\end_layout

\begin_layout Standard
If multiple ttlimits symbols are provided, then the engine will scan each
 in order, and extract matching information from the first time it is found.
 That means that if you specify ^s in both ttlimits and ttlimits3, for example,
 it will be extracted from ttlimits and ignored in ttlimits3.
 OpenHoldem allows you to specify up to 11 ttlimits records in any single
 Table Map file.
 Specifying multiple ttlimits records might be needed if a given Table Map
 file is intended to describe multiple Texas Hold’em game flavors.
 However, it is a best practice to define different game flavors in different
 Table Maps, and thus most Table Maps contain a single ttlimits symbol record.
 c0limits, c0limits0-c0limits9 These are text format strings with the same
 structure as the ttlimits records described above.
 They are intended to be used to extract blind/limit information from the
 c0limits regions using text transforms.
 As a poker site could certainly paint the various blind/limit information
 in different locations in the window, it is very likely that multiple c0limits
 records are required, if any are needed at all.
 sitename This record describes the name of the poker site that this Table
 Map is for.
 It is good practice to include the number of chairs and game flavor that
 this Table Map is intended to be used for.
 You might have a "fulltilt9sng", "fulltilt6ring" and "fulltilt2ring" for
 different Table Map files for Full Tilt's various table layouts and flavors.
 This record is what is queried via the OpenHoldem "sitename$" symbol.
 network The name of the poker network that this Table Map is for.
 This is used to determine the appropriate network to query Poker Tracker
 data for when s$sitename is not a Poker Tracker-supported site.
 OpenHoldem will first check s$sitename for a supported network name, then
 s$network.
 
\end_layout

\begin_layout Standard
Supported names for both s$sitename and s$network must be lowercase and
 are the following: stars, party, ultimate, absolute, microgaming, ongame,
 cryptologic, pacific, fulltilt, b2b, tribeca, worldpex, ipoker, tain, bodog,
 everest, boss, and betfair.
 nchairs The number of chairs that this Table Map supports.
 The value of this record is what is returned via the OpenHoldem "nchairs"
 symbol.
 reseller Legacy support of WinScrape's symbol.
 Not particularly relevant in the open source OpenScrape world, but there
 if you need it.
 This is not used in the OpenHoldem engine anywhere, and is just metadata
 for the Table Map file.
 mechanic Legacy support of WinScrape's symbol.
 Not particularly relevant in the open source OpenScrape world, but there
 if you need it.
 This is not used in the OpenHoldem engine anywhere, and is just metadata
 for the Table Map file.
 chairconfig Legacy support of WinScrape's symbol.
 OpenHoldem does not adjust its display layout based on the value of this
 symbol like WinHoldem, and thus this is not used in the OpenHoldem engine
 anywhere.
 swagtextmethod Used by the Autoplayer to determine how to enter the f$swag
 amount into the swag entry box on the casino window.
 potmethod This is used to determine the appropriate site interpretation
 for the contents of c0pot0: 1: Common pot 2: Total pot, includes current
 bets and side bets activemethod This is used to determine how OH treats
 information from the pXactive and uXactive regions: 1: Inactive unless
 pXactive/uXactive returns true/active 2: Active unless pXactive/uXactive
 returns false/inactive/out/away t0type - t3type These symbols control which
 OCR algorithm will get used for the specific text transform 0-3.
 For example if the symbol h3type is defined as fuzzy then all regions with
 transform Text3 will use the fuzzy algorithm.
 The default value is "plain" if no symbol exists for a given group.
\end_layout

\begin_layout Standard
The possible values for these symbols are "fuzzy", "plain", or a specific
 tolerance value.
 The default fuzzy text tolerance is 25%, but can be overridden by stating
 the value in this symbol, such as "0.355", which would cause the scraper
 engine to use the fuzzy text algorithm with a 35.5% tolerance value.
 Values of 0 are the same as "plain".
 swagselectionmethod * New Symbol in version 2.0; previously, this was a
 global preference set from the OpenHoldem preferences GUI.
\end_layout

\begin_layout Standard
This symbol instructs the Autoplayer how to take the first action in a SWAG
 sequence.
 A SWAG sequence always consists of: 1.
 select the text in the SWAG box 2.
 delete the text in the SWAG box 3.
 enter the new bet in the SWAG box 4.
 confirm the SWAG bet amount.
\end_layout

\begin_layout Standard
Valid values for this Symbol are available in a drop down control and are:
 "Sgl Click" – Single left click on the SWAG box to select the existing
 text "Dbl Click" – Double left click on the SWAG box to select the existing
 text "Click Drag" – Left click on the leftmost pixel of the SWAG box, drag
 to the rightmost pixel of the SWAG box, and then release the left mouse
 button to select the existing text "Nothing" – Skip the text selection
 step of the SWAG action swagdeletionmethod * New Symbol in version 2.0;
 previously, this was a global preference set from the OpenHoldem preferences
 GUI.
\end_layout

\begin_layout Standard
This symbol instructs the Autoplayer how to take the second action in a
 SWAG sequence.
 A SWAG sequence always consists of: 1.
 select the text in the SWAG box 2.
 delete the text in the SWAG box 3.
 enter the new bet in the SWAG box 4.
 confirm the SWAG bet amount.
\end_layout

\begin_layout Standard
Valid values for this Symbol are available in a drop down control and are:
 "Delete" – Press the “Delete” key to delete the selected text in the SWAG
 box "Backspace" – Press the “Backspace” key to delete the selected text
 in the SWAG box "Nothing" – Skip the text deletion step of the SWAG action
 swagconfirmationmethod * New Symbol in version 2.0; previously, this was
 a global preference set from the OpenHoldem preferences GUI.
\end_layout

\begin_layout Standard
This symbol instructs the Autoplayer how to take the fourth action in a
 SWAG sequence.
 A SWAG sequence always consists of: 1.
 select the text in the SWAG box 2.
 delete the text in the SWAG box 3.
 enter the new bet in the SWAG box 4.
 confirm the SWAG bet amount.
\end_layout

\begin_layout Standard
Valid values for this Symbol are available in a drop down control and are:
 "Enter" – Press the “Enter” key to confirm the SWAG bet entry "Click Bet"
 – Click the “Bet” button to confirm the SWAG bet entry "Nothing" – Skip
 the bet confirmation step of the SWAG action buttonclickmethod * New Symbol
 in version 2.0; previously, this was a global preference set from the OpenHoldem
 preferences GUI.
\end_layout

\begin_layout Standard
This symbol instructs the Autoplayer how to click any button defined by
 the iXbutton region records.
\end_layout

\begin_layout Standard
Valid values for this Symbol are available in a drop down control and are:
 "Single" – Single left click on buttons "Double" – Double left click on
 buttons handresetmethod * New Symbol in version 2.0
\end_layout

\begin_layout Standard
This symbol identifies which scrape changes should be used as a trigger
 to identify a "hand reset" event.
 This is a bitmapped integer; only one of the selected scrape changes needs
 to occur in order for the scrape to be considered a "hand reset".
 
\end_layout

\begin_layout Standard
The values below are in hexadecimal format for explanatory purposes, but
 the value assigned to the handresetmethod symbol must be specified in decimal
 (base-10) format.
 As an example, if you want to instruct OpenHoldem to treat a change in
 dealer button OR a change in player cards as a "hand reset", then handresetmeth
od should be set to 5.
 If you want to instruct OpenHoldem to treat only a change in dealer button
 as a “hand reset", then handresetmethod should be set to 1.
\end_layout

\begin_layout Standard
Bits and meanings: 0x00000001 (bit 1) = dealer button 0x00000010 (bit 2)
 = handnumber 0x00000100 (bit 3) = player cards (not triggered by change
 to "no cards" or to "card backs") balancenumbersonly * New Symbol in version
 2.0
\end_layout

\begin_layout Standard
This Symbol instructs the screen scraper that all characters besides numbers
 (0-9 and dot/decimal separator) are stripped from the text transform result
 for balance regions.
 This is useful for those casinos that include spurious/changing alphanumeric
 information in their balance boxes.
 Setting this string to "True" or "Yes" will enable balance cleansing, any
 other value or the absence of this Symbol will result in no balance cleansing.
 chipscrapemethod * New Symbol in version 2.0
\end_layout

\begin_layout Standard
This Symbol instructs the “chip stack counter” within the screen scraper
 engine to act in one of three distinct modes of operation: If this Symbol
 is not present, or does not match one of the other formats, the “chip stack
 counter” begins counting chips at the 00 Region record, stops counting
 a given stack when a chip match is not found, and stops counting all stacks
 when the first chip in a given stack is not matched.
 This is the default, pre-2.0 behavior.
 If this symbol is set to "All”, then the scraper engine will check all
 200 possible chip locations (10 stacks of 20 chips) every time a chip count
 is required.
 If this symbol is set to the format "XxY", where X is an integer between
 1 and 10 representing the number of stacks, and Y is an integer between
 1 and 20 representing the number of chips in each stack, then the scraper
 engine will check X times Y chip locations every time a chip count is required.
 Scraperdll * New Symbol in version 2.0
\end_layout

\begin_layout Standard
This Symbol instructs OpenHoldem to load a user-supplied external scraper
 override DLL when this Table Map is used.
 This external DLL can be used to override the results of the internal scraper
 engine.
 This DLL is called immediately after the internal scraper engine finishes
 its pass every heartbeat, at which point the current state of the internal
 screen scraper is passed to the DLL for inspection and modification.
 A reference scraper DLL is provided in the source code as a starting point.
 An obvious use of this would be to hook or inject the target casino client
 to retrieve better state information than that which could be collected
 using the built-in pixel-based screen scraper.
 
\end_layout

\begin_layout Section
Region Records
\end_layout

\begin_layout Standard
Description The purpose of the Region records is to describe named rectangular
 areas on a poker table, each of which contains an element of the game state.
 These regions will “return” values to the OpenHoldem game state engine,
 depending on the type of transform selected.
\end_layout

\begin_layout Standard
An example will make this clearer.
 Each seat at the table will have two cards in front it, and we want our
 screen scraper to tell the OpenHoldem game state engine what those cards
 are.
 If the casino client displays a group of pixels for our first hole card,
 that to a human being looks like an ace of hearts, we need somehow to tell
 the screen scraper to “return” “Ah” to the game state engine each time
 that group of pixels is seen in one of the card locations.
 To do this we collect an image for that ace of hearts, then setup a region
 record that returns “Ah” to OpenHoldem when that ace of hearts is seen
 during real live game play.
 Manipulating region records using OpenScrape To create a new region record,
 select the “Regions” category in the record tree display on the Table Map
 Editor window, and click the “New” button.
 A window will be displayed that allows you to select the name of the region
 to create.
 After creating the record, you can use the controls on the right side of
 the Table Map Editor window, as described below, to change the settings
 for the new record.
 To edit an existing region record, select the record in the record tree
 display on the Table Map Editor window.
 Immediately after selecting the record, the controls on the right side
 of the Table Map Editor window are updated with the settings for the selected
 region record.
 These can then be changed, as described below.
 To delete an existing region record, select the record in the record tree
 display on the Table Map Editor window, and click the “Delete” button.
 A window will be displayed asking for verification of this action.
\end_layout

\begin_layout Standard
Note: The Insert and Delete keys can also be used as a shortcut for adding
 and deleting Region records.
\end_layout

\begin_layout Standard
Note: Regions can also be selected by left clicking within the region’s
 flashing red rectangle that is layered on top of the poker table image
 on the Main window.
 If multiple regions are layered on top of each other, clicking again on
 the same area will select the next region below the selected region.
 This only works for two regions.
 If three or more regions are layered on top of each other, the selection
 tree will need to be used.
\end_layout

\begin_layout Standard
The majority of the right side of the Table Map Editor window is used to
 manipulate the parameters of the region record.
 
\end_layout

\begin_layout Standard
Figure 4.5-11 OpenScrape Rectangle Group Box
\end_layout

\begin_layout Standard
Starting at the top, there is a rectangle group box.
 This group box allows you to define the extents (left, right, top, bottom)
 of the region record’s bounding rectangle.
 The bounds are inclusive – in other words, a rectangle defined as left=0,
 right=5, top=0 and bottom=6 will be 6 pixels wide and 7 pixels high.
 The rectangle settings can be direct entered into the controls, you can
 use the spinners next to the controls, or you can use the rectangle drawing
 tool to quickly draw the rectangle on the poker table.
 
\end_layout

\begin_layout Standard
To use the rectangle drawing tool, click once on this control:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_RectangleDrawTool.bmp

\end_inset


\end_layout

\begin_layout Standard
...then move your mouse cursor to the Main OpenScrape window where the image
 of the poker table is displayed.
 The mouse cursor will change to look like crosshairs with an arrow pointing
 right and down.
 Left click and hold the mouse button anywhere on the poker table image
 to define the left-top corner of the rectangle.
 Drag to the right and down, and when you reach the right-bottom corner
 of the rectangle, release the left mouse button.
\end_layout

\begin_layout Standard
A zoomed view of the region is displayed in the box at the bottom right
 of the Table Map Editor window.
 The Table Map Editor window can be enlarged, if needed, to show the entire
 region.
 Use the Zoom Level control to adjust the zoom level in this display.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_NudgeGroupBox.bmp

\end_inset


\end_layout

\begin_layout Standard
To the right of the rectangle group box is the nudge group box.
 These controls allow you to adjust the size and position of the region
 record’s rectangle in a variety of ways.
 The group of six controls on the left, starting from top left and moving
 clockwise, allow you to make the rectangle taller, shorter, thinner, smaller,
 bigger and wider.
 The group of 8 controls on the right, starting from top left and moving
 clockwise, allow you to move the rectangle up-left, up, up-right, right,
 down-right, down, down-left, and left.
\end_layout

\begin_layout Standard
Note: Regions can also be moved by first selecting the region by left clicking
 within the region’s flashing red rectangle on the poker table image on
 the Main window, then by holding the Shift key and dragging and dropping
 the region to its new location.
\end_layout

\begin_layout Standard
Note: Keyboard shortcuts also exist to move and resize regions: Arrow keys
 - Move the region 1 pixel Numpad keys 1, 3, 7, and 9 – Move the region
 diagonally 1 pixel Shift + Arrow keys - Move the region 5 pixels Control
 + Arrow keys - Resize the region by 1 pixel Control + Shift + Arrow keys
 – Resize the region by 5 pixels
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_RegionRecordParameters.bmp

\end_inset


\end_layout

\begin_layout Standard
The next set of controls allows you to set the remainder of the parameters
 on a region record.
 Here you can set the type of transform, the radius of the RGB color cube,
 and the center color of the RGB color cube.
 The use of RGB color cubes for transforms of type Color and Text is described
 in the technical reference below.
 Also in this group of controls is an eyedropper button that is used to
 populate the color parameters, as opposed to directly entering those values.
 To use the eyedropper, click once on the eyedropper button, then hover
 over the region’s image display at the bottom of the Table Map Editor window.
 When the color you want is present in the four color fields, click the
 left mouse button to lock them in.
\end_layout

\begin_layout Standard
As a helpful reference, the “Avg Color” fields are populated with the calculated
 average color of all pixels in the region.
 This is useful for finding RGB color cube centers and for text transform
 separations.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_TransformResultPreview.bmp

\end_inset


\end_layout

\begin_layout Standard
This field provides an instant preview of the results of combining the current
 pixels in the region with the current transform for that region.
 If this is a Text transform, the actual transformed ASCII text is displayed.
 If this is a Color transform, True or False is displayed, depending if
 the region’s average color is inside or outside of the defined RGB color
 cube.
 If this is a Hash transform, the value of the matching Hash record is displayed.
 If this is an Image transform, the value of the matching Image record is
 displayed.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_PixelSeparationDisplay.bmp

\end_inset


\end_layout

\begin_layout Standard
If your region is defined to have a Text transform, then the Pixel Separation
 window will be populated with a preview of this separation.
 The key to good Text transformation is the separation of foreground pixel
 colors from background pixel colors.
 In this display, foreground pixels will be shown as an “X”, and background
 pixels as a blank space.
 The size of the font used in this display can be adjusted with the “+”
 and “-“ buttons to the right.
\end_layout

\begin_layout Standard
Note: Remember that the whole purpose of a region definition, with a given
 type of transformation, is to tell the screen scraper what the pixels mean
 that are displayed on the screen within that region.
 The return value of the transformation is provided to the OpenHoldem game
 state engine which then uses those values to establish the game state and
 to provide various information that your bot logic needs to make action
 decisions.
 A human can easily look at the balance for seat #2 and see that it is $950.12.
 For a computer it is harder – we need to specify the rectangle that bounds
 this balance region, define it as a text transform, choose a color that
 lets the screen scraper identify foreground from background pixels, and
 then collect each of the individual font characters (more on this below)
 so that the screen scraper engine can look up the actual ASCII text for
 these pixels.
\end_layout

\begin_layout Standard
The Edit menu of on the Main window contains a “Duplicate Region” entry,
 which is intended to allow the quick creation of related region records.
 First, select a region record from the tree display on the Table Map Editor
 window, then select Edit/Duplicate Region from the Main window.
 This action will display this window:
\end_layout

\begin_layout Standard
Figure 4.5-17 OpenScrape Duplicate Region window
\end_layout

\begin_layout Standard
In this case, the p0balance region was selected.
 You are given the option to duplicate the selected region record to other
 region records of the same type.
 In this case, all of the unpopulated pXbalance and uXbalance region records
 are candidates.
 You can select one or more than one destination record here (using the
 standard Windows Ctrl and Shift multi-select capability) to copy the selected
 region to.
 When you click the OK button, the new region records will be created for
 you, and you can then move them where needed and adjust them appropriately.
\end_layout

\begin_layout Standard
Technical Reference In the Table Map (.tm) file, these records will be preceded
 with the characters "r$".
 Region records have the following format: 
\end_layout

\begin_layout Standard
r$<name> <left> <top> <right> <bottom> <color> <radius> <transform>
\end_layout

\begin_layout Standard
<name> is the name of the record (see table below) <left>, <top>, <right>
 and <bottom> are integer values within the casino table, where the upper
 left corner of the client area is considered to be 0, 0 <color> is a 1-8
 character hexadecimal number in the form AABBGGRR (Microsoft Window's COLORREF
 format).
 The usage of the color value is dependent on the transform selected.
 <radius> is an RGB color distance.
 <transform> describes the engine algorithm that should be used to interpret
 the pixels in the region.
 
\end_layout

\begin_layout Standard
The available transforms are: Type Description N None - This is used for
 those regions that do not need a transform as their only purpose is to
 describe a rectangle for use by the scraper engine.
 An example is button location (i0button - i9button) which informs the Autoplaye
r engine of the allowed rectangle for mouse clicks.
 C Color - This is a calculation of the average RGB color for the entire
 region.
 Used in conjunction with the radius, the engine will determine if the contents
 of the region, as seen during game play, match the color/radius as specified
 in the Table Map.
 The color value in the region record defines the center of a cube, and
 the radius defines the dimensions of that cube.
 This cube is then mapped to an RGB color space, and if the average color
 of the region falls within this cube, then a match is reported.
 A negative radius can also be specified, in which case if the average color
 of the region falls outside of the cube, then a match is reported.
 I Image - This transform does two things.
 It first searches the Image records in the Table Map for a pixel-by-pixel
 match, and returns the value of that Image record if a match is found.
 If no pixel-by-pixel match is found, the transform then searches for the
 closest match, based on this perceptual difference algorithm: http://pdiff.sourc
eforge.net/ There is an internal hard-coded limit, which prevents Image records
 from matching the region if 65% or more of available pixels of that region
 do not match.
 If this limit did not exist, then clearly non-matching regions could return
 all sorts of junk.
 This exact-match-to-pdiff failover is automatic, and requires no additional
 work from the Table Map creator other than to set the transform to "I"
 and to collect the images.
 This is a powerful transform, but be aware that this power comes at the
 cost of CPU cycles.
 T Text - This is an OCR (http://en.wikipedia.org/wiki/Optical_character_recogniti
on) algorithm for the purpose of converting screen pixels to ASCII text.
 The color cube specifications (as in the C transform) are used to separate
 the foreground from the background pixels.
 A lookup is then performed against the Font records in the Table Map on
 a character by character basis to produce a resultant text string.
 Hn Hash n - This transform reduces the contents of the rectangle to a 32-bit
 value.
 OpenHoldem and OpenScrape use only a single, well respected hash algorithm
 that is open for public review.
 Because of the selection of this algorithm, we have not yet seen a hash
 collision (that did not have an unrelated root cause, like record duplication).
 That is not to say that a hash collision is not impossible, however the
 mapping of 52 card images (for example) into a 32-bit address space makes
 this highly unlikely.
 If a collision ever occurs, there is the option to use hash types other
 than Type 0.
 Types 0-3 all use different hash seeds with the same algorithm, and thus
 if a collision is seen, one could simply change the hash type for that
 region.
 
\end_layout

\begin_layout Standard
The Type 0 hash algorithm uses all pixels in a region to calculate a hash.
 To use specific pixels in the region, use Types 1-3.
 Types 1-3 default to using all pixels in a region as well, but if Hash
 Point records are present in the Table Map and of a matching type, the
 engine will use those specific points for calculation of the hash.
 
\end_layout

\begin_layout Standard
Once a region is hashed, the resultant 32-bit hash value is then looked
 up in the h$ records in the Table Map.
 If a match is found, the name of the h$ record is returned and acted on
 appropriately (i.e.
 common card 1 is Queen-Hearts, Fold button is present, Player 2 is seated,
 etc.) 
\end_layout

\begin_layout Standard
Valid region records and their descriptions: Record Description c0cardface0
 - c0cardface4 Common cards 0-4; represents the entire card, the best transforma
tion is probably hash.
 Typically either c0cardfaceX is used, or c0cardfaceXrank / c0cardfaceXsuit,
 but not both.
 Valid results are a case-insensitive, two character string.
 The first character is the rank and should be one of: “2”, “3”, “4”, “5”,
 “6”, “7”, “8”, “9”, “t”, “j”, “q”, “k”, or “a”.
 The second character is the suit and should be one of: “c”, “d”, “h” or
 “s”.
 c0cardface0rank - c0cardface4rank Rank of common cards 0-4; the best transforma
tion is probably text.
 Typically either c0cardfaceX is used, or c0cardfaceXrank / c0cardfaceXsuit,
 but not both.
 Valid results are case-insensitive, and are one of “2”, “3”, “4”, “5”,
 “6”, “7”, “8”, “9”, “10”, “t”, “j”, “q”, “k”, or “a”.
 c0cardface0suit - c0cardface4suit Suit of common cards 0-4; the best transforma
tion is probably text.
 Typically either c0cardfaceX is used, or c0cardfaceXrank / c0cardfaceXsuit,
 but not both.
 Valid results are case-insensitive, and are one of “c”, “d”, “h” or “s”.
 c0handnumber, c0handnumber1 - c0handnumber9 Ten regions to specify where
 the game state engine should find the current handnumber.
 The first region found with valid numeric information will be used and
 the remainder skipped.
 c0handnumber is searched first, then c0handnumber1 to c0handnumber9 in
 that order.
 c0istournament Used to identify if this table is a tournament game.
 Any transform can be used equally well with this region.
 If the result from this region’s transform is anything besides blank (empty
 string) then this region is considered to represent a tournament game.
 c0smallblind Identifies the region on the poker table where the small blind
 can be found.
 Title text parsing is much easier to implement if that option is available,
 otherwise a text transformation can be used with this region to identify
 the small blind.
 c0bigblind Identifies the region on the poker table where the big blind
 can be found.
 Title text parsing is much easier to implement if that option is available,
 otherwise a text transformation can be used with this region to identify
 the big blind.
 c0bigbet Identifies the region on the poker table where the big bet can
 be found.
 Title text parsing is much easier to implement if that option is available,
 otherwise a text transformation can be used with this region to identify
 the big bet.
 c0ante Identifies the region on the poker table where the ante can be found.
 Title text parsing is much easier to implement if that option is available,
 otherwise a text transformation can be used with this region to identify
 the ante.
 c0pot0 - c0pot4 The value of the main pot should be identified by c0pot0
 using a text transform.
 c0pot1 to c0pot4 can be used to identify side pots if required.
 c0potNchipXY See chip scraping instructions for p0chipXY - p9chipXY below.
 The difference is that the "N" refers to the different pots - N=0 is the
 main pot, N=1-4 are side pots.
 c0limits, c0limits0 - c0limits9 Identifies the region on the casino table
 where the limit information can be found; this region is used in conjunction
 with the Symbol records c0limits and c0limits0-c0limit9 text parse strings.
 This region should really only be used if title text parsing is not an
 option.
 i0button - i9button Specifies the rectangular area in which the Autoplayer
 can click the mouse for each button 0-9.
 i0label - i9label Specifies the action that should be associated with buttons
 0-9.
 By default, and if not overridden here, button 0 will be interpreted as
 the fold button, 1 as the call button, 2 as the raise button and 3 as the
 allin button.
 
\end_layout

\begin_layout Standard
The return value from the transformation of this region (hash or text) will
 determine how the scraper engine interprets the button.
 All values are changed to lowercase and have spaces and '-' removed.
 Only the leftmost characters will be tested "allin", "a11in", "allln",
 "a111n", "aiiin" : button is seen as the allin button "raise", "ra1se",
 "ralse", "bet" : button is seen as the raise button "call", "caii", "ca11" :
 button is seen as the call button "check" : button is seen as the check
 button "fold", "fo1d", "foid" : button is seen as the fold button "autopost",
 "aut0p0st" : button is seen as the autopost button "sitin", "s1t1n" : button
 is seen as the sitin button "sitout", "s1tout", "sit0ut", "s1t0ut" : button
 is seen as the sitout button "leave" : button is seen as the leave button
 "prefold" : button is seen as the prefold button 
\end_layout

\begin_layout Standard
Examples: "All-In" will be recognized as allin; "Auto-post blinds" will
 be recognized as autopost i0labelY - i9labelY Where Y = 0 - 9.
 As an adjunct to the iXlabel regions, the iXlabelY region definitions allow
 the specification of an alternative location with alternate properties,
 such as color, for any button.
 The specification of these regions is exactly as that of the iXlabel regions
 with an addition of a numeric (0 - 9) suffix.
 The iXlabel regions are searched first, then the iXlabelY regions.
 The first region that resolves to a text value will stop any subsequent
 evaluations.
 i0state - i9state Specifies whether the button0 - button9 is live and available
 to be clicked.
 The best transformation is hash or color.
 If the leftmost characters of the result from this region’s transform are
 either “true”, "on", "yes", "checked" or "lit" then the button will be
 seen as available to be clicked.
 If any other result is returned, such as "false", then the button will
 be seen as not available to be clicked.
 Results are case-insensitive.
 i3edit Specifies the rectangular region that can be used for entering a
 SWAG bet.
 i86button, i860button - i869button Similar to the i0button - i9button regions,
 however these regions are intended to be used to combat spam/popups that
 could occlude the poker window.
 If the corresponding state region returns true, the Autoplayer will try
 to click in this region to dismiss the spam/popup.
 i86state, i860state - i869state The corresponding state regions for the
 i86button, i860button - i869button regions above.
 The best transformation is hash or color.
 If the leftmost characters of the result from this region’s transform are
 either “true”, "on", "yes", "checked" or "lit" then the button will be
 seen as available to be clicked.
 If any other result is returned, such as "false", then the button will
 be seen as not available to be clicked.
 Results are case-insensitive.
 p0active - p9active Used to determine if a player is active (sitting in)
 or not (sitting out).
 Any transform can be used equally well with this region.
 If the leftmost characters of the result from this region’s transform are
 either “true” or “active”, then the region is considered to be active.
 If any other result is returned, such as "false", "inactive", "out" or
 "away", then the chair is not considered to be active.
 Results are case-insensitive.
 p0balance - p9balance Used to identify a player's balance.
 It only makes sense to use a text transform for these regions.
 p0bet - p9bet Used to identify a player's bet.
 It only makes sense to use a text transform for these regions.
 p0cardback - p9cardback Used to identify when a seat 0-9 displays a card
 back.
 The best transformation is hash or color.
 If the leftmost characters of the result from this region’s transform are
 either “true” or “cardback”, then the region is considered to be showing
 a cardback.
 If any other result is returned, such as "false", then the chair is not
 considered to have be showing a cardback.
 Results are case-insensitive.
 p0cardface0 - p9cardface0 The first card for seats 0-9; represents the
 entire card.
 The best transformation is probably hash.
 Typically either pXcardfaceY is used, or pXcardfaceYrank / pXcardfaceYsuit,
 but not both.
 Valid results are a case-insensitive, two character string.
 The first character is the rank and should be one of: “2”, “3”, “4”, “5”,
 “6”, “7”, “8”, “9”, “t”, “j”, “q”, “k”, or “a”.
 The second character is the suit and should be one of: “c”, “d”, “h” or
 “s”.
 p0cardface1 - p9cardface1 The second card for seats 0-9; represents the
 entire card.
 The best transformation is probably hash.
 Typically either pXcardfaceY is used, or pXcardfaceYrank / pXcardfaceYsuit,
 but not both.
 Valid results are a case-insensitive, two character string.
 The first character is the rank and should be one of: “2”, “3”, “4”, “5”,
 “6”, “7”, “8”, “9”, “t”, “j”, “q”, “k”, or “a”.
 The second character is the suit and should be one of: “c”, “d”, “h” or
 “s”.
 p0cardface0rank - p9cardface0rank The rank of the first card for seats
 0-9.
 The best transformation is probably text.
 Typically either pXcardfaceY is used, or pXcardfaceYrank / pXcardfaceYsuit,
 but not both.
 Valid results are case-insensitive, and are one of “2”, “3”, “4”, “5”,
 “6”, “7”, “8”, “9”, “10”, “t”, “j”, “q”, “k”, or “a”.
 p0cardface0suit - p9cardface0suit The suit of the first card for seats
 0-9.
 The best transformation is probably text.
 Typically either pXcardfaceY is used, or pXcardfaceYrank / pXcardfaceYsuit,
 but not both.
 Valid results are case-insensitive, and are one of “c”, “d”, “h” or “s”.
 p0cardface1rank - p9cardface1rank The rank of the second card for seats
 0-9.
 The best transformation is probably text.
 Typically either pXcardfaceY is used, or pXcardfaceYrank / pXcardfaceYsuit,
 but not both.
 Valid results are case-insensitive, and are one of “2”, “3”, “4”, “5”,
 “6”, “7”, “8”, “9”, “10”, “t”, “j”, “q”, “k”, or “a”.
 p0cardface1suit - p9cardface1suit The suit of the second card for seats
 0-9.
 The best transformation is probably text.
 Typically either pXcardfaceY is used, or pXcardfaceYrank / pXcardfaceYsuit,
 but not both.
 Valid results are case-insensitive, and are one of “c”, “d”, “h” or “s”.
 p0dealer - p9dealer Identifies if the dealer button is found for seat 0-9,
 or not.
 Color transforms are usually used for these regions, but hash, text or
 image transforms can be used too.
 If the leftmost characters of the result from this region’s transform are
 either “true” or “dealer”, then the chair is considered to have the dealer
 button.
 If any other result is returned, such as "false", then the chair is not
 considered to have the dealer button.
 Results are case-insensitive.
 p0name - p9name Identifies the name of the player in seat 0-9.
 It only makes sense to use a text transform for these regions.
 p0seated - p9seated Identifies whether seat 0-9 is occupied (seated) or
 not.
 Color transforms are usually used for these regions, but hash, text or
 image transforms can be used too.
 If the leftmost characters of the result from this region’s transform are
 either “true” or “seated”, then the chair is considered to be seated.
 If any other result is returned, such as "false" or "unseated", then the
 chair is not considered to be seated.
 Results are case-insensitive.
 p0chipXY - p9chipXY Note: Chip scraping should *only* be used if the actual
 numeric bet text cannot be found elsewhere on the poker table.
 Text transformation is magnitudes of effort easier to accomplish.
 
\end_layout

\begin_layout Standard
Step 1 : Ensure that the poker site uses static landings for all of the
 chip stacks.
 Step 2 : Determine the size of an individual chip, and should include any
 portion of the chip that is painted anywhere within the window regardless
 of how faded or transparent.
 Step 3 : Create regions for the initial base of each player's chip stacks
 with the size determined in step 2; p0chip00, p1chip00, ..., p9chip00.
 Step 4 : Create vertical stride chip regions for each player's chip stack;
 p0chip01, p1chip01, ..., p9chip01.
 These regions should perfectly surround the 2nd chip that rests above the
 base pXchip00.
 Step 5 : Create horizontal stride chip regions for each player's chip stack;
 p0chip10, p1chip10, ..., p9chip10.
 These regions should perfectly surround the base chip in the second stack.
 Step 6 : Optional and rare: If the vertical stride between chips in a stack
 is not uniform, then you will need to define pXchip02-pXchip09 for each
 chip in the stack.
 For those sites with non-uniform vertical chip strides, this means that
 there is a limit of 10 chips per stack that will be recognized by the engine.
 Step 7 : Optional and rare: If the horizontal stride between chip stacks
 is not uniform, then you will need to define pXchip10-pXchip90 for each
 stack.
 For those sites with non-uniform horizontal chip strides, this means that
 there is a limit of 10 stacks that will be recognized by the engine.
 In a worst case situation, there may be 100 chip regions * 10 players =
 1000 region definitions required to scrape chips! (So now go look at scraping
 the bet text instead) u0active - u9active These are alternatives to the
 p0active-p9active regions, and are used for the player's seat.
 They are typically used when the player's seat changes appearance when
 it is the player's action, to avoid misscrapes due to change in color/size,
 whatever.
 Any transform can be used equally well with this region.
 If the leftmost characters of the result from this region’s transform are
 either “true” or “active”, then the region is considered to be active.
 If any other result is returned, such as "false", "inactive", "out" or
 "away", then the chair is not considered to be active.
 Results are case-insensitive.
 ubalance, u0balance - u9balance These are alternatives to the p0balance-p9balan
ce regions, and are used for the player's seat.
 They are typically used when the player's seat changes appearance when
 it is the player's action, to avoid misscrapes due to change in color/size,
 whatever.
 It only makes sense to use a text transform for these regions.
 u0bet – u9bet * New Symbol in version 2.0
\end_layout

\begin_layout Standard
These are alternatives to the p0bet-p9bet regions, and are used for the
 player's seat.
 They are typically used when the player's seat changes appearance when
 it is the player's action, to avoid misscrapes due to change in color/size,
 whatever.
 It only makes sense to use a text transform for these regions.
 u0cardface0 - u9cardface0 These are alternatives to the p0cardface0-p9cardface0
 regions, and are used for the player's seat.
 They are typically used when the player's seat changes appearance when
 it is the player's action, to avoid misscrapes due to change in color/size,
 whatever.
 Valid results are a case-insensitive, two character string.
 The first character is the rank and should be one of: “2”, “3”, “4”, “5”,
 “6”, “7”, “8”, “9”, “t”, “j”, “q”, “k”, or “a”.
 The second character is the suit and should be one of: “c”, “d”, “h” or
 “s”.
 u0cardface1 - u9cardface1 These are alternatives to the p0cardface1-p9cardface1
 regions, and are used for the player's seat.
 They are typically used when the player's seat changes appearance when
 it is the player's action, to avoid misscrapes due to change in color/size,
 whatever.
 Valid results are a case-insensitive, two character string.
 The first character is the rank and should be one of: “2”, “3”, “4”, “5”,
 “6”, “7”, “8”, “9”, “t”, “j”, “q”, “k”, or “a”.
 The second character is the suit and should be one of: “c”, “d”, “h” or
 “s”.
 u0dealer – u9dealer * New Symbol in version 2.0
\end_layout

\begin_layout Standard
These are alternatives to the p0dealer-p9dealer regions, and are used for
 the player's seat.
 They are typically used when the player's seat changes appearance when
 it is the player's action, to avoid misscrapes due to change in color/size,
 whatever.
 Color transforms are usually used for these regions, but hash, text or
 image transforms can be used too.
 If the leftmost characters of the result from this region’s transform are
 either “true” or “dealer”, then the chair is considered to have the dealer
 button.
 If any other result is returned, such as "false", then the chair is not
 considered to have the dealer button.
 Results are case-insensitive.
 uname, u0name - u9name These are alternatives to the p0name-p9name regions,
 and are used for the player's seat.
 They are typically used when the player's seat changes appearance when
 it is the player's action, to avoid misscrapes due to change in color/size,
 whatever.
 It only makes sense to use a text transform for these regions.
 u0seated - u9seated These regions are alternatives to the p0seated-p9seated
 regions, and are used for the player's seat.
 They are typically used when the player's seat changes appearance when
 it is the player's action, to avoid misscrapes due to change in color/size,
 whatever.
 Color transforms are usually used for these regions, but hash, text or
 image transforms can be used too.
 If the leftmost characters of the result from this region’s transform are
 either “true” or “seated”, then the chair is considered to be seated.
 If any other result is returned, such as "false" or "unseated", then the
 chair is not considered to be seated.
 Results are case-insensitive.
 tablepointNNN These regions are used when the "Green Circle Button" is
 clicked on the OpenHoldem toolbar to "automagically" find a table to connect
 to.
 These regions must be one pixel wide by one pixel tall and must use a color
 transform.
 All tablepoint records must match the pixel colors on the casino window
 for it to be recognized on a connect.
 See {How the “Green Circle Button” finds tables} for more details.
 
\end_layout

\begin_layout Section
Font Records
\end_layout

\begin_layout Standard
Description Font records are used as lookup records for Regions that utilize
 Text transformations.
 When a Text transformation is required for a region, the foreground pixels
 in that region will be scanned left to right, and the widest font record
 that matches those pixels will be considered a match.
 The region will continue to be scanned left to right until all the pixels
 in the region are consumed.
 The return value of that region’s text transform is this entire sequence
 of ASCII characters.
\end_layout

\begin_layout Standard
Manipulating font records using OpenScrape
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_CreateFont.bmp

\end_inset


\end_layout

\begin_layout Standard
The “Create Font” button on the Table Map Editor window is used to create
 new font records.
 This button is only available if a Text transform is specified for the
 selected region record.
 
\end_layout

\begin_layout Standard
To create new font records: 1.Select a Region record that has a text transform
 2.Ensure that the Region’s color parameters provide good separation of foregroun
d and background pixels (preview in the Pixel Separation field) 3.Click the
 “Create Font” button
\end_layout

\begin_layout Standard
Note: The number of the text transform in the region (Text0, Text1, Text2,
 or Text3) determines which Font record group (0 to 3) the new fonts will
 be added to.
\end_layout

\begin_layout Standard
Assuming that some of the pixels in the selected region represent unknown
 font characters, then the following window will appear when the “Create
 Font” button is clicked:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_AddFontRecord.bmp

\end_inset


\end_layout

\begin_layout Standard
On this window, a list of the individual font characters that OpenScrape
 thinks it has found is displayed in the list on the left side.
 As we have not told OpenScrape what character each of these pixel groups
 represent, they are displayed as question marks.
 (Note that the question mark can be considered a valid font character as
 well, so if you use this character in your Table Map, be aware of this
 fact).
\end_layout

\begin_layout Standard
For each unknown character in the list on the left, click to select it,
 then either: Enter which character is represents in the “Character” field
 (in this example, it is evident that the grouping of foreground pixels
 represents the capital letter P), or Click on the “Delete” button if this
 is not a character you want stored in the Table Map for some reason, such
 as it is a duplicate, or the automatic character separation didn’t work
 quite correctly
\end_layout

\begin_layout Standard
Clicking on the “Sort” button will arrange the characters alphabetically
 in the list, which might make them easier to process.
\end_layout

\begin_layout Standard
When you dismiss this window by clicking on the “OK” button, OpenScrape
 will add each of the characters in the list on the left, their ASCII representa
tion, and their pixel layout to the list of Table Map records.
 This includes duplicates, and unknowns (question marks), so be sure to
 remove these prior to clicking “OK”, or your Table Map might get filled
 with superfluous Font records.
\end_layout

\begin_layout Standard
Fuzzy fonts “Fuzzy fonts” are sometimes used by casinos when displaying
 text on their poker interfaces.
 You can identify if a casino uses fuzzy fonts by looking closely at the
 pixel patterns for individual characters as they are displayed at different
 times or in different locations on the screen.
 (Hint: use zoom) As an example, if when you look at the capital “A” character
 as it is displayed for seat 0’s name vs.
 seat 1’s name, you can see that those two letters use different pixels,
 of different colors, especially on the slanted arms of the “A”, you generally
 will need to use fuzzy font recognition.
\end_layout

\begin_layout Standard
The general procedure for defining fuzzy font records is as follows: 1.Decide
 which fonts will be fuzzy, and create those in a different Font group from
 your other fonts (we will use group 1 “Text1” in this example).
 Fonts can be created with the font color defined as the foreground pixel
 color, or the background color as the foreground pixel color.
 In the case of the latter, the so-called inverse fonting may sometimes
 give better results.
 Experiment! If using the font color for the foreground pixel color, it
 is probably best to make the fonts as thick as possible using a large RGB
 color cube radius.
 If using the background color as the foreground pixel color, a radius of
 zero probably works best.
 2.Create a t1type Symbol record (for the Text1 group), and set the free-form
 text to "fuzzy" for default tolerance (25%), or to a specific tolerance
 value (0.50 for 50%, 0.33 for 33%, for example).
 Experiment to find the best tolerance – all casinos are different in how
 they display fuzzy fonts.
 If this symbol is set to anything besides "fuzzy" or a floating point value,
 then the engine will used non-fuzzy font recognition engine.
 3.You can also create multiple samples for various characters, and it will
 help.
 The numbers “6”, “8”, and “3”, for example, are similar enough that distinguish
ing fuzzy versions of these is difficult.
 Creating more font records (samples) for the various 6's, 8s and 3's will
 help with the recognition.
 
\end_layout

\begin_layout Standard
Technical Reference In the Table Map (.tm) file, these records will be preceded
 with the characters "t$".
 Font records have the following format: 
\end_layout

\begin_layout Standard
T<n>$<a> <x0> <x1> <x2> ...
 <x30>
\end_layout

\begin_layout Standard
<n> is the font group (0-3) that this font record belongs to <a> is an actual
 printable (non-whitespace) case-sensitive ASCII character (note that the
 angle brackets <> are not used) <x0> to <x30> are 32bit hexadecimal values
 that describe the foreground pixels for the character.
 The maximum individual character width is 31 pixels.
 These values describe the on-off state of the pixels for the character,
 with 1 meaning on (foreground) and 0 meaning off (background).
 
\end_layout

\begin_layout Section
Hash Point Records
\end_layout

\begin_layout Standard
Description The purpose of Hash Point records is to define the pixels within
 a region that are used in a hash calculation.
 The “Hash0” transform always uses all pixels in a region to calculate its
 hash, so these records are only relevant for regions that use “Hash1”,
 “Hash2”, or “Hash3” transforms.
\end_layout

\begin_layout Standard
There is a one to one correlation between the “Hash1”, “Hash2”, or “Hash3”
 transforms and the group 1, 2 and 3 Hash Point records.
 For example, a region that calls for a “Hash2” transform will use the pixels
 specified by the group 2 Hash Point records in the hash calculation.
\end_layout

\begin_layout Standard
The points defined for a Hash Point group must fall within the boundaries
 of the regions that you are calculating a hash for.
 Hash Points that fall outside of the region will be ignored, as they are
 invalid.
 For example, if you have card regions that are 10x20 pixels, then hash
 points (11,15) and (8,22) will be ignored, whereas hash points (5,5) and
 (9, 18) will be used in the hash calculation.
 Manipulating hash point records using OpenScrape There are two ways to
 create new Hash Point records:
\end_layout

\begin_layout Standard
1.Select the “Hash Points” category in the record tree display on the Table
 Map Editor window, and click the “New” button.
 A window will be displayed that allows you to enter the hash point group
 and the X and Y parameters:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_CreateHashPoint.bmp

\end_inset


\end_layout

\begin_layout Standard
2.Somewhat less intuitively, but ultimately easier to use, is to select the
 “Hash Points” category in the record tree display on the Table Map Editor
 window, and click the “Edit” button.
 A window will be displayed that allows you to select the hash point group,
 a sample image, and then interactively define the Hash Points for that
 group:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_NewHashPoint.bmp

\end_inset


\end_layout

\begin_layout Standard
When you select a Hash Point group from the “Hash Type” control, the “Hash
 Point List” box will populate with all the Hash Points currently defined
 for that group.
 In this case, the box is empty, as we have not yet defined any Hash Point
 records for group 1.
\end_layout

\begin_layout Standard
After selecting an Image record in the “Sample Image” control (note you
 need to have Image records created first for this to work), the right side
 of the window will display that image and overlay the Hash Points for the
 selected group, like so:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_NewHashPointWithImage.bmp

\end_inset


\end_layout

\begin_layout Standard
The zoom level of the sample image can be adjusted with the “Zoom Level”
 control.
 Adding Hash Points can be done interactively by left-clicking on the sample
 image where the point is needed.
 Right clicking on an existing point in the sample image will remove it
 from the group.
\end_layout

\begin_layout Standard
Clicking the “OK” button will then make the changes (adds and deletes) to
 the Table Map Hash Pointe record list.
 To edit an existing Hash Point record, select the record in the record
 tree display on the Table Map Editor window, and click the “Edit” button.
 A window will be displayed that allows you to edit the hash point group
 and the X and Y parameters.
 To delete an existing symbol record, select the record in the record tree
 display on the Table Map Editor window, and click the “Delete” button.
 A window will be displayed asking for verification of this action.
 An entire group of Hash Points can also be edited and/or deleted by selecting
 the “Hash Points” category in the record tree display on the Table Map
 Editor window, and clicking the “Edit” button.
 This will bring up the Graphical Hash Point Editor window, as described
 above.
\end_layout

\begin_layout Standard
Note: The Insert and Delete keys can also be used as a shortcut for adding
 and deleting individual Hash Point records.
\end_layout

\begin_layout Standard
Technical Reference In the Table Map (.tm) file, these records will be preceded
 with the characters "p$".
 Hash point records have the following format: 
\end_layout

\begin_layout Standard
p<n>$ <x> <y>
\end_layout

\begin_layout Standard
<n> is the group (1-3) that this hash point record belongs to <x> and <y>
 are the coordinates of the point, relative to the region's rectangle, the
 top left corner of which is 0,0.
 
\end_layout

\begin_layout Section
Hash Records
\end_layout

\begin_layout Standard
Description The purpose of Hash Records is to allow for the rapid lookup
 of pixel patterns, without having to scan through each pixel in a region
 to find a match.
 For example, if we have a card region specified to use a “Hash0” transform,
 the screen scraper engine will first reduce the pixels in that region to
 a 32-bit hash value.
 (A link to Bob Jenkins’ hash algorithm that is used in this project can
 be found in the references section) Once the screen scraper engine has
 calculated the 32-bit hash value, it looks to see if there exists a matching
 32-bit value in the associated group of Hash Records, in this example,
 group 0.
 If a matching 32-bit hash value is found, the screen scraper engine returns
 the <name> of the Hash Record to the game state engine.
 Manipulating hash records using OpenScrape Hash Records are created from
 specific Image records, so in order to create a Hash record, you must first
 have collected the associated Image record (see section {4.9}).
 
\end_layout

\begin_layout Standard
Figure 4.8-23 OpenScrape Create Hash Record buttons
\end_layout

\begin_layout Standard
The “Create Hash” buttons on the Table Map Editor window are used to create
 new Hash records.
 Button “0” creates Hash records in the Hash0 group, button “1” creates
 Hash records in the Hash1 group, and so on.
 These buttons are only available if an Image record has been selected in
 the tree display on the Table Map Editor window.
 
\end_layout

\begin_layout Standard
Note: Only one Hash record can exist in a Table Map in each hash group for
 any given Image record.
 Otherwise, there would be collisions, and the screen scraper engine would
 not know which Hash record was the correct match.
 In the “Create Hash Record buttons” screenshot above, Hash records for
 group 0 and 2 have already been created for the selected Image record,
 so those buttons are grayed out.
\end_layout

\begin_layout Standard
To create a new Hash records: 1.Select an Image record 2.Click the “Create
 Hash” button for the hash group that you want to create this Hash record
 in.
\end_layout

\begin_layout Standard
The following window will then appear to confirm the addition of the new
 Hash record: 
\end_layout

\begin_layout Standard
Figure 4.8-24 OpenScrape New Hash record confirmation
\end_layout

\begin_layout Standard
When you add a new Hash record with the “Create Hash” buttons, OpenScrape
 will calculate the hash value for you and add it to the record.
 (This is new behavior in 2.0; previous versions stored a zero hash value
 on new record creation) However, sometimes you may need to change that
 stored hash value, if for example, you replace the underlying Image record,
 or you change the number or location of the related Hash Points.
 If one or more hash values need to be updated, use the “Update Hashes”
 option on the Edit manu on the Main window, and the hash values on all
 Hash records will be re-calculated.
 Technical Reference In the Table Map (.tm) file, these records will be preceded
 with the characters "h$".
 Hash records have the following format: 
\end_layout

\begin_layout Standard
h<n>$<name> <value>
\end_layout

\begin_layout Standard
<n> is the group (1-3) that this hash record belongs to <name> is the string
 that is returned to the scraper engine upon a match (the “result”) <value>
 is a 32bit hexadecimal value that contains the calculated hash .
\end_layout

\begin_layout Section
Image Records 
\end_layout

\begin_layout Standard
Description Image records serve multiple purposes.
 The first purpose is for regions that use the Image transform.
 When a region requires this type of lookup, the screen scraper engine will
 first look for an exact pixel-for-pixel image match in the Image records,
 and if no match is found, will then look for the closest match (with the
 65% tolerance, as described in the Region Records {Technical Reference}
 section).
 The second purpose of the Image records is to serve as a reference from
 which Hash records are created (see the {Hash Records} section).
 Note: Image transforms are very CPU intensive, as they require 2 passes
 through the Image records, the first to try to find an exact match, and
 the second to find a closest match.
 Each pass requires a comparison of every single pixel in the region.
 For large regions, this is a lot of comparisons.
 The time required to do Image transform lookups is directly proportional
 to the number of Image records present, and the size of the requesting
 Region record.
 It almost always makes more sense to use the Hash transform to do image
 matching, as the Hash lookup algorithm is orders of magnitude faster.
\end_layout

\begin_layout Standard
Manipulating image records using OpenScrape
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_CreateImage.bmp

\end_inset


\end_layout

\begin_layout Standard
The “Create Image” button on the Table Map Editor window is used to create
 new Image records.
 This button is only available if a region record has previously been selected.
\end_layout

\begin_layout Standard
When the “Create Font” button is clicked, the following window will appear:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename C:/Dokumente und Einstellungen/TheRoot/Desktop/OH_SVN/trunk/Documentation/Images/OpenScrape/OS_NewImage.bmp

\end_inset


\end_layout

\begin_layout Standard
The only required piece of information on this window is the name of the
 Image record, however, the name you choose is crucially important, as this
 name is what is returned to the game state engine directly for an Image
 transform, and is what is populated on the Hash record when you create
 a hash from this image.
\end_layout

\begin_layout Standard
The name is dependent on what the image is used for, but for example, if
 this is an image of the ace of clubs, you would want to name it “Ac”.
 If this is an image of a dealer button, you would want to name it “dealer”.
 (See the Region Records section, {Technical Reference}, for valid return
 values for each region)
\end_layout

\begin_layout Standard
Technical Reference In the Table Map (.tm) file, these records will be preceded
 with the characters "i$".
 Image records have the following format:
\end_layout

\begin_layout Standard
i$<name> width height scanline0 scanline1 ...
 scanlineN
\end_layout

\begin_layout Standard
<name> is the description of the image, and is the value returned to the
 screen scraper engine or is the name given to an associated Hash record
 <width> and <height> are integer values that give the size of the image
 <scanline0> - <scanlineN> contain the raw 32bit hexadecimal values for
 each pixel.
 Each pixel is in the form BBGGRRAA.
 There is no whitespace between pixel values.
 Each scanline is terminated with a standard Microsoft Windows line ending
 (carriage return/line feed).
 The number of scanline records is equal to the height of the image.
 The text length of a scanline record is width*8.
 
\end_layout

\begin_layout Section
Converting Table Maps 
\end_layout

\begin_layout Standard
During the course of time both OpenScrape and the tablemap-format got improved.
 Especially tablemaps for version 1.x and 2.x differ significantly, so it
 is recommended to convert old tablemaps to the newest format
\begin_inset Marginal
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Images/Hint.jpg

\end_inset


\end_layout

\end_inset

.
 To do so it is  usually sufficient to
\end_layout

\begin_layout Itemize
open the TM with the newest verion of OpenScrape
\end_layout

\begin_layout Itemize
save it again
\end_layout

\begin_layout Itemize
review, if it works
\end_layout

\end_body
\end_document
